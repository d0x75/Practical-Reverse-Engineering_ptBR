[Previous](../intro.md)
------------------------


# Chapter 0x01 - x86 and x64


O x86 é a arquitetura little-endian baseada no processador Intel 8086. Para o propósito de nosso capítulo, x86 é a implementação de 32 bits da arquitetura Intel (IA-32), conforme definido no Intel Software Development Manual. De um modo geral,o IA-32 pode operar em dois modos: *real e protegido*. O modo real é o estado do processador quando é ligado pela primeira vez e suporta apenas um conjunto de instruções de 16 bits. O modo protegido é o estado do processador com suporte
para memória virtual, paginação e outros recursos; é o estado em que os sistemas operacionais modernos são executados. A extensão de 64 bits da arquitetura é chamada de x64 ou x86-64. Este capítulo discute o **x86** operando em modo protegido.


O x86 oferece suporte ao conceito de separação de privilégios por meio duma abstração conhecida como Ring Level. O processador
suporta quatro Ring Levels, numerados de 0 a 3.(Os rings 1 e 2 não são comumente usados/conhecidos, portanto não são discutidos
aqui.) O Ring 0 é o nível que possui privilégio mais alto e pode modificar todas as configurações do sistema.O Ring 3 é o nível
de privilégios mais baixo e só pode ler/modificar um subconjunto das configurações do sistema. Portanto,sistemas operacionais
modernos geralmente implementam a separação de privilégios de Userland/Kerneland por ter aplicativos em user-mode executados
no Ring 3 e os de kernel-mode no Ring 0. O Ring Level é codificado no registrador **CS** e às vezes referido como o nível de
privilégio atual (CPL) na documentação oficial.

>Este capítulo discute a arquitetura x86 / IA-32 conforme definida no Intel 64 e IA-32 Architectures Software Developer’s
Manual, Volumes 1–3 (www.intel.com/content/www/us/en/processors/architectures-software-developermanuals.html)




Registers Set and Data Types
-----------------------------

**GPRs - General Porpouse Registers** - registradores de uso geral


Ao operar em Protect-mode, a arquitetura x86 fornece 8 registradores de uso geral (GPRs) de 32 bits. São eles:

		EAX, EBX, ECX, EDX, EDI, ESI, EBP, and ESP.

Alguns destes podem ser subdividios em registradores de 16 ou 8 bits. Exemplo :
			
		EAX = 32 bits
		AX = 16 bits
		AL ou AH = 8 bits

_Alguns registradores e seus objetivos de origem_:


Registrador | Objetivo
------------| ----------------------------------------------------
ECX 	    | usado como contador nas implementações de loop
ESI         | usado como origem em operações com strings/memory
EDI         | usado como destino em operações com strings/memory
EBP         | Base frame pointer
ESP			| Stack pointer



Tipos de dados, e suas nomeclaturas mais cumuns :


- BYTE (8 bits)

		Ex : AL,BL,AH,BH

- WORD (16 bits)

		Ex : AX,BX,SI

- DWORD (32 bits)

		Ex : EAX,EBX,EDI

- QWORD (64 bits)

Embora o x86 não tenha GPRs de 64 bits, ele pode combinar dois registradores, tipo( EDX:EAX ), e tratá-los como valores de 64 bits em alguns cenários; por exemplo usando a instrução [RDTSC](https://docs.microsoft.com/pt-br/cpp/intrinsics/
rdtsc?view=msvc-160) é possível gravar um valor de 64 bits em EDX:EAX



O Instruction Pointer(ponteiro p/ próxima instrução), é armazenado no registrador :

		EIP = 32 bits / address of EP

O registrador EFLAGS de 32 bits é usado para armazenar o status de operações aritméticas e outros estados de
execução. Quando a instrução anterior resultou em zero, **ZF**(Zero Flag, que é uma das flags mais importantes do EFLAGS)
será definido como 1. As flags de EFLAGS são usados principalmente para implementar ramificação condicionais.

		EFLAGS = 32 bits / cada bit = 1 FLAG


Além dos GPRs, EIP e EFLAGS, também existem registradores que controlam mecanismos importantes do sistema de low-level,como
virtual memory, interrupts e degugging. Por exemplo :

		CR0 = controla se a paginação está ativada ou desativada
		CR2 = contém o endereço linear que causou uma falha de página
		CR3 = é o endereço base de uma estrutura de dados de paginação
		CR4 = controla as configurações de virtualização de hardware.

		DR0 – DR7 =  são usados por Memory Breakpoints.
		Voltaremos a esses registradores mais tarde na seção “Mecanismo do sistema”.

_NOTE: Embora haja sete registradores de debugging, o sistema permite apenas quatro Memory BreakPoints (DR0-DR3).
Os registradores restantes são usados para validar status._


Existem também registradores específicos do modelo (MSRs). Como o nome indica, esses registradores podem variar entre os
diferentes processadores da Intel e AMD. Cada MSR é identificado por nome e um número de 32 bits, e é lido/escrito por meio
das instruções RDMSR/WRMSR. Eles são acessíveis apenas ao código rodando em ring 0 e normalmente são usados para armazenar
contadores especiais e implementar funcionalidade de low-level. Por exemplo, a instrução assembly *SYSENTER* transfere a
execução para o endereço armazenado no IA32_SYSENTER_EIP MSR (0x176), que geralmente é o manipulador das chamadas de sistema
(systemsCalls). MSRs são discutidos ao longo do livro à medida que aparecem.



------


Instrutions Set ( conjunto de instruções )
---------------------------------------------


O conjunto de instruções que o x86 fornece, são bem flexivéis em termos de movimentação de dados entre registers and memory.
Essa movimentação de dados, pode ser classificada em 5 tipos :

- Imediato p/ Registrador
- Registrador p/ Registrador
- Imediato p/ Memória
- Registrador p/ Memória e vice-versa
- Memória p/ Memória


Os primeiros quatro métodos são suportados por todas as arquiteturas modernas, mas o último é específico para x86.
Uma arquitetura RISC clássica como ARM só pode _read/write_ dados de memóriá p/ memória com instruções de load/store. 
(LDR and STR respectiva).Por exemplo uma operação simples como incrementar um valor na memória requer 3 instruções :

 1. Ler dados da memória para um registrador (LDR).
 2. Adicionar 1 ao registrador (ADD).
 3. Gravar o registrador na memória (STR)

No x86, tal operação exigiria apenas uma instrução (INC ou ADD) porque pode acessar a memória diretamente. A instrução MOVS
pode ler e escrever na memória ao mesmo tempo. Veja os exemplos :


**ARM**


	01: 1B 68 LDR R3, [R3] ; read the value at address R3
	02: 5A 1C ADDS R2, R3, #1 ; add 1 to it
	03: 1A 60 STR R2, [R3] ; write updated value back to address R3


**x86**


	01: FF 00 inc dword ptr [eax]
	; directly increment value at address EAX


Outra feature importante é que o x86 usa o tamanho de instruções de comprimento variável: no o comprimento da instrução pode variar de 1 a 15 bytes. 
No ARM, as instruções têm 2 ou 4 bytes de comprimento.



Sintaxe
---------


Dependendo o assembler/disassembler, existem 2 variações de sintaxe da linguagem assembly x88 : Intel ou AT&T .


**Intel**


	mov ecx, AABBCCDDh
	mov ecx, [eax]
	mov ecx, eax


**AT&T**


	movl $0xAABBCCDD, %ecx
	movl (%eax), %ecx
	movl %eax, %ecx


É importante observar que essas são as mesmas instruções, mas escritas em sintaxes diferentes. Existem várias
diferenças entre a notação Intel e AT&T, mas as mais notáveis são as seguintes:


- A AT&T prefixa os registradores com *%* e imediatos com *$*. Intel não faz isso.

- A AT&T adiciona um prefixo à instrução para indicar a largura da operação. Por exemplo, MOVL (long), MOVB (byte),
etc.. A Intel não faz isso.

- A AT&T coloca o operando de origem antes do destino. A Intel inverte a ordem.


Disassemblers/Assemblers e outras ferramentas de engenharia reversa (IDA Pro, OllyDbg, MASM, etc.) no Windows geralmente usam a notação Intel, enquanto aqueles no UNIX frequentemente seguem a notação 
AT&T (GCC). Na prática, a notação Intel é a forma dominante e é usada ao longo deste livro.



Data Movement ( Movendo dados)
-------------------------------

As instruções operam com valores que vem de registradores ou da main memory. A instrução mais comum
para mover dados é a instrução *MOV*.Exemplo de uso simples: MOV um registrador ou um imediato para um
registrador.

Exemplo de código 1:

		01: BE 3F 00 0F 00 mov esi, 0F003Fh ; set ESI = 0xF003
		02: 8B F1 		   mov esi, ecx     ; set ESI = ECX

O próximo uso comum é mover dados DE/PARA memória. Semelhante a outras convenções da linguagem
assembly o x86 usa o Colchetes __[]__ para indicar acesso na memória.
( a única exceção é a instrução LEA, que usam [] mas na verdade não faz referência a memória)
O acesso a memória pode ser especificado de meneiras diferentes, portando começaremos com o caso mais 
simples :

*Assembly*

	01: C7 00 01 00 00+ mov dword ptr [eax], 1 ; set the memory at address EAX to 1
	02: 8B 08 			mov ecx, [eax] 		   ; set ECX to the value at address EAX
	03: 89 18 			mov [eax], ebx         ; set the memory at address EAX to EBX
	04: 89 46 34 		mov [esi+34h], eax     ; set the memory address at (ESI+34) to EAX
	05: 8B 46 34 		mov eax, [esi+34h]     ; set EAX to the value at address (EAX+34)
	06: 8B 14 01 		mov edx, [ecx+eax]     ; set EDX to the value at address (ECX+EAX)


*Pseudo C*

	01: *eax = 1;
	02: ecx = *eax;
	03: *eax = ebx;
	04: *(esi+34) = eax;
	05: eax = *(esi+34);
	06: edx = *(ecx+eax);


Esses exemplos demonstram o acesso à memória por meio de um registrador base e um offset , onde o
offset pode ser um registrador ou um operadando imediato. Essa forma é comumente usada para acessar
itens das structs ou buffers de dados em um local calculado em tempo de execução.Por exemplo,suponha
que *ECX* aponte para uma struct do tipo _KDPC_ com o seguinte layout :

	kd> dt nt!_KDPC
		 +0x000 Type : UChar
		 +0x001 Importance : UChar
		 +0x002 Number : Uint2B
		 +0x004 DpcListEntry : _LIST_ENTRY
		 +0x00c DeferredRoutine : Ptr32 void
		 +0x010 DeferredContext : Ptr32 Void
		 +0x014 SystemArgument1 : Ptr32 Void
		 +0x018 SystemArgument2 : Ptr32 Void
		 +0x01c DpcData : Ptr32 Void


E usado no seguinte contexto:

*Assembly*

	01: 8B 45 0C 		mov eax, [ebp+0Ch]
	02: 83 61 1C 00 	and dword ptr [ecx+1Ch], 0
	03: 89 41 0C 		mov [ecx+0Ch], eax
	04: 8B 45 10 		mov eax, [ebp+10h]
	05: C7 01 13 01 00+ mov dword ptr [ecx], 113h
	06: 89 41 10 		mov [ecx+10h], eax

*Pseudo C*

	KDPC *p = ...; 00?
	p->DpcData = NULL; 02!
	p->DeferredRoutine = ... ;03!
	*(int *)p = 0x113; 05?
	p->DeferredContext = ...; 06!


A linha 1 lê um valor da memória e o armazena no registrador *EAX*. O campo _DeferredRoutine_ é definido com este
valor na linha 3. A linha 2 limpa o campo _DpcData_ usando o operador *AND* com 0. a linha 4 lê outro valor da
memória e armazena em *EAX* e por fim o campo _DeferredContext_ é definido com o último valor guardado em *EAX* na
linha 6.

A linha 5 escreve uma DWORD com valor 0x113 na base da struct. Como ele escreve uma DWORD na base, se o primeiro campo da struct tem apenas 1 BYTE de tamanho?
