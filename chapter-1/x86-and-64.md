[Previous](../intro.md)
------------------------


# Chapter 0x01 - x86 and x64


O x86 é a arquitetura little-endian baseada no processador Intel 8086. Para o propósito de nosso capítulo, x86 é a
implementação de 32 bits da arquitetura Intel (IA-32), conforme definido no Intel Software Development Manual. De um modo
geral,o IA-32 pode operar em dois modos: *real e protegido*. O modo real é o estado do processador quando é ligado pela primeira vez e suporta apenas um conjunto de instruções de 16 bits. O modo protegido é o estado do processador com suporte
para memória virtual, paginação e outros recursos; é o estado em que os sistemas operacionais modernos são executados. A
extensão de 64 bits da arquitetura é chamada de x64 ou x86-64. Este capítulo discute o **x86** operando em modo protegido.


O x86 oferece suporte ao conceito de separação de privilégios por meio duma abstração conhecida como Ring Level. O processador
suporta quatro Ring Levels, numerados de 0 a 3.(Os rings 1 e 2 não são comumente usados/conhecidos, portanto não são discutidos
aqui.) O Ring 0 é o nível que possui privilégio mais alto e pode modificar todas as configurações do sistema.O Ring 3 é o nível
de privilégios mais baixo e só pode ler/modificar um subconjunto das configurações do sistema. Portanto,sistemas operacionais
modernos geralmente implementam a separação de privilégios de Userland/Kerneland por ter aplicativos em user-mode executados
no Ring 3 e os de kernel-mode no Ring 0. O Ring Level é codificado no registrador **CS** e às vezes referido como o nível de
privilégio atual (CPL) na documentação oficial.

>Este capítulo discute a arquitetura x86 / IA-32 conforme definida no Intel 64 e IA-32 Architectures Software Developer’s
Manual, Volumes 1–3 (www.intel.com/content/www/us/en/processors/architectures-software-developermanuals.html)




Registers Set and Data Types
-----------------------------

**GPRs - General Porpouse Registers** - registradores de uso geral


Ao operar em Protect-mode, a arquitetura x86 fornece 8 registradores de uso geral (GPRs) de 32 bits. São eles:

		EAX, EBX, ECX, EDX, EDI, ESI, EBP, and ESP.

Alguns destes podem ser subdividios em registradores de 16 ou 8 bits. Exemplo :
			
		EAX = 32 bits
		AX = 16 bits
		AL ou AH = 8 bits

_Alguns registradores e seus objetivos de origem_:


Registrador | Objetivo
------------| ----------------------------------------------------
ECX 	    | usado como contador nas implementações de loop
ESI         | usado como origem em operações com strings/memory
EDI         | usado como destino em operações com strings/memory
EBP         | Base frame pointer
ESP			| Stack pointer



Tipos de dados, e suas nomeclaturas mais cumuns :


- BYTE (8 bits)

		Ex : AL,BL,AH,BH

- WORD (16 bits)

		Ex : AX,BX,SI

- DWORD (32 bits)

		Ex : EAX,EBX,EDI

- QWORD (64 bits)

Embora o x86 não tenha GPRs de 64 bits, ele pode combinar dois registradores, tipo( EDX:EAX ), e tratá-los como valores de 64 bits em alguns cenários; por exemplo usando a instrução [RDTSC](https://docs.microsoft.com/pt-br/cpp/intrinsics/
rdtsc?view=msvc-160) é possível gravar um valor de 64 bits em EDX:EAX



O Instruction Pointer(ponteiro p/ próxima instrução), é armazenado no registrador :

		EIP = 32 bits / address of EP

O registrador EFLAGS de 32 bits é usado para armazenar o status de operações aritméticas e outros estados de
execução. Quando a instrução anterior resultou em zero, **ZF**(Zero Flag, que é uma das flags mais importantes do EFLAGS)
será definido como 1. As flags de EFLAGS são usados principalmente para implementar ramificação condicionais.

		EFLAGS = 32 bits / cada bit = 1 FLAG


Além dos GPRs, EIP e EFLAGS, também existem registradores que controlam mecanismos importantes do sistema de low-level,como
virtual memory, interrupts e degugging. Por exemplo :

		CR0 = controla se a paginação está ativada ou desativada
		CR2 = contém o endereço linear que causou uma falha de página
		CR3 = é o endereço base de uma estrutura de dados de paginação
		CR4 = controla as configurações de virtualização de hardware.

		DR0 – DR7 =  são usados por Memory Breakpoints.
		Voltaremos a esses registradores mais tarde na seção “Mecanismo do sistema”.

_NOTE: Embora haja sete registradores de debugging, o sistema permite apenas quatro Memory BreakPoints (DR0-DR3).
Os registradores restantes são usados para validar status._


Existem também registradores específicos do modelo (MSRs). Como o nome indica, esses registradores podem variar entre os
diferentes processadores da Intel e AMD. Cada MSR é identificado por nome e um número de 32 bits, e é lido/escrito por meio
das instruções RDMSR/WRMSR. Eles são acessíveis apenas ao código rodando em ring 0 e normalmente são usados para armazenar
contadores especiais e implementar funcionalidade de low-level. Por exemplo, a instrução assembly *SYSENTER* transfere a
execução para o endereço armazenado no IA32_SYSENTER_EIP MSR (0x176), que geralmente é o manipulador das chamadas de sistema
(systemsCalls). MSRs são discutidos ao longo do livro à medida que aparecem.



------


Instrutions Set ( conjunto de instruções )
---------------------------------------------


O conjunto de instruções que o x86 fornece, são bem flexivéis em termos de movimentação de dados entre registers and memory.
Essa movimentação de dados, pode ser classificada em 5 tipos :

- Imediato p/ Registrador
- Registrador p/ Registrador
- Imediato p/ Memória
- Registrador p/ Memória e vice-versa
- Memória p/ Memória


Os primeiros quatro métodos são suportados por todas as arquiteturas modernas, mas o último é específico para x86.
Uma arquitetura RISC clássica como ARM só pode _read/write_ dados de memóriá p/ memória com instruções de load/store. 
(LDR and STR respectiva).Por exemplo uma operação simples como incrementar um valor na memória requer 3 instruções :

 1. Ler dados da memória para um registrador (LDR).
 2. Adicionar 1 ao registrador (ADD).
 3. Gravar o registrador na memória (STR)

No x86, tal operação exigiria apenas uma instrução (INC ou ADD) porque pode acessar a memória diretamente. A instrução MOVS
pode ler e escrever na memória ao mesmo tempo. Veja os exemplos :


**ARM**


	01: 1B 68 LDR R3, [R3] ; read the value at address R3
	02: 5A 1C ADDS R2, R3, #1 ; add 1 to it
	03: 1A 60 STR R2, [R3] ; write updated value back to address R3


**x86**


	01: FF 00 inc dword ptr [eax]
	; directly increment value at address EAX


Outra feature importante é que o x86 usa o tamanho de instruções de comprimento variável: no o comprimento da instrução pode variar de 1 a 15 bytes. 
No ARM, as instruções têm 2 ou 4 bytes de comprimento.



Sintaxe
---------


Dependendo o assembler/disassembler, existem 2 variações de sintaxe da linguagem assembly x88 : Intel ou AT&T .


**Intel**


	mov ecx, AABBCCDDh
	mov ecx, [eax]
	mov ecx, eax


**AT&T**


	movl $0xAABBCCDD, %ecx
	movl (%eax), %ecx
	movl %eax, %ecx


É importante observar que essas são as mesmas instruções, mas escritas em sintaxes diferentes. Existem várias
diferenças entre a notação Intel e AT&T, mas as mais notáveis são as seguintes:


- A AT&T prefixa os registradores com *%* e imediatos com *$*. Intel não faz isso.

- A AT&T adiciona um prefixo à instrução para indicar a largura da operação. Por exemplo, MOVL (long), MOVB (byte),
etc.. A Intel não faz isso.

- A AT&T coloca o operando de origem antes do destino. A Intel inverte a ordem.


Disassemblers/Assemblers e outras ferramentas de engenharia reversa (IDA Pro, OllyDbg, MASM, etc.) no Windows
geralmente usam a notação Intel, enquanto aqueles no UNIX frequentemente seguem a notação AT&T (GCC). Na prática, a
notação Intel é a forma dominante e é usada ao longo deste livro.





