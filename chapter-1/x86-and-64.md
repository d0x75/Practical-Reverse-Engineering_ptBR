[Previous](../intro.md)
------------------------


# Chapter 0x01

x86 and x64
--------------



- O x86 é a arquitetura little-endian baseada no processador Intel 8086. Para o propósito de nosso capítulo, x86 é a
implementação de 32 bits da arquitetura Intel (IA-32), conforme definido no Intel Software Development Manual. De um modo
geral, pode operar em dois modos: real e protegido. O modo real é o estado do processador quando é ligado pela primeira vez e
suporta apenas um conjunto de instruções de 16 bits. O modo protegido é o estado do processador com suporte para memória
virtual, paginação e outros recursos; é o estado em que os sistemas operacionais modernos são executados. A extensão de 64
bits da arquitetura é chamada de x64 ou x86-64. Este capítulo discute o Arquitetura x86 operando em modo protegido.

- O x86 oferece suporte ao conceito de separação de privilégios por meio de uma abstração chamada Ring Level. O processador
suporta quatro Ring Levels, numerados de 0 a 3. (Os rings 1 e 2 não são comumente usados, portanto não são discutidos
aqui.) O Ring 0 é o nível de privilégio mais alto e pode modificar todas as configurações do sistema. O Ring 3 é o nível de
privilégios mais baixo e só pode ler/modificar um subconjunto das configurações do sistema. Portanto, os sistemas
operacionais modernos geralmente implementam a separação de privilégios de Userland/Kerneland por ter aplicativos em
user-mode executados no Ring 3 e os de kernel-mode no Ring 0. O Ring Level é codificado no registrador CS e às vezes referido
como o nível de privilégio atual (CPL) na documentação oficial.


Este capítulo discute a arquitetura x86 / IA-32 conforme definida no Intel 64 e IA-32 Architectures Software Developer’s Manual, Volumes 1–3 (www.intel.com/content/www/us/en/processors/architectures-software-developermanuals.html)




### Registers Set and Data Types


**GPRs - General Porpouse Registers**


- Ao operar em Protect-mode, a arquitetura x86 fornece 8 registradores de uso geral de 32 bits. São os seguintes GPRs:

		EAX, EBX, ECX, EDX, EDI, ESI, EBP, and ESP.

- Alguns destes podem ser subdividios em registradores de 16 ou 8 bits.
- O Instruction Pointer(ponteiro da proxima instrução), é armazenado no registrador :

		EIP


_Alguns registradores e seus propósitos_:

ECX = usado como contador nas implementações de loop
ESI = usado como origem em operações com strings/memory
EDI = usado como destino em operações com strings/memory

EBP = Base frame pointer
ESP = Stack pointer


- Tipos de dados mais cumuns :


**BYTE** - 8 bits . 	Ex : AL,BL,AH,BH
**WORD** - 16 bits . 	Ex : AX,BX,SI
**DWORD**- 32 bits .  	Ex : EAX,EBX,EDI
**QWORD**- 64 bits . 	Embora o x86 não tenha GPRs de 64 bits, ele pode combinar dois registradores, tipo( EDX:EAX ), e
tratá-los como valores de 64 bits em alguns cenários. Exemplo: , a instrução **RDTSC** grava um valor de 64 bits em EDX:EAX


**EFLAGS** = O registrador EFLAGS de 32 bits é usado para armazenar o status de operações aritméticas e outros estados de
execução (por exemplo, Trap Flag). Quando a instrução "ADD" anterior resultou em zero, **ZF**(Zero Flag) será definido como 1.
As flags de EFLAGS são usados principalmente para implementar ramificação condicionais.


- Além dos GPRs, EIP e EFLAGS, também existem registradores que controlam mecanismos importantes do sistema de low-level,como
virtual memory, interrupts e degugging. Por exemplo :

CR0 = controla se a paginação está ativada ou desativada
CR2 = contém o endereço linear que causou uma falha de página
CR3 = é o endereço base de uma estrutura de dados de paginação
CR4 = controla as configurações de virtualização de hardware. 
DR0 – DR7 =  são usados por Memory Breakpoints.Voltaremos a esses registradores mais tarde na seção “Mecanismo do sistema”.

_NOTE: Embora haja sete registradores de debugging, o sistema permite apenas quatro Memory BreakPoints (DR0-DR3).
Os registradores restantes são usados para status._


- Existem também registradores específicos do modelo (MSRs). Como o nome indica, esses registradores podem variar entre os
diferentes processadores da Intel e AMD. Cada MSR é identificado por nome e um número de 32 bits, e é lido/escrito por meio
das instruções RDMSR/WRMSR. Eles são acessíveis apenas ao código rodando em ring 0 e normalmente são usados para armazenar
contadores especiais e implementar funcionalidade de low-level. Por exemplo, a instrução **SYSENTER** transfere a execução
para o endereço armazenado no IA32_SYSENTER_EIP (MSR (0x176), que geralmente é o sistema operacional que gerencia as
systemsCalls ( chamadas de sistema ). MSRs são discutidos ao longo do livro à medida que aparecem.



### Instrutions Set

- 

