[Previous](../intro.md)
------------------------


# Capítulo 0x01 - x86 and x64



O x86 é a arquitetura little-endian baseada no processador Intel 8086. Para o propósito de nosso capítulo, x86 é a implementação de 32 bits da arquitetura Intel (IA-32), conforme definido no Intel Software Development Manual. De um modo geral,o IA-32 pode operar em dois modos: *real e protegido*. O modo real é o estado do processador quando é ligado pela primeira vez e suporta apenas um conjunto de instruções de 16 bits. O modo protegido é o estado do processador com suporte para memória virtual, paginação e outros recursos; é o estado em que os sistemas operacionais modernos são executados. A extensão de 64 bits da arquitetura é chamada de x64 ou x86-64. Este capítulo discute o **x86** operando em modo protegido.


O x86 oferece suporte ao conceito de separação de privilégios por meio duma abstração conhecida como Ring Level. O processador
suporta quatro ring levels, numerados de 0 a 3.(Os rings 1 e 2 não são comumente usados/conhecidos, portanto não são discutidos
aqui.) O __Ring 0__ é o nível que possui privilégio mais alto e pode modificar todas as configurações do sistema.O __Ring 3__ é o nível
de privilégios mais baixo e só pode ler/modificar um subconjunto das configurações do sistema. Portanto,sistemas operacionais
modernos geralmente implementam a separação de privilégios de user/kernel por ter aplicativos em user-mode executados
no Ring 3 e os de kernel-mode no Ring 0. O __ring revel__ é codificado no registrador **CS** e às vezes referido como o nível de
privilégio atual (CPL) na documentação oficial.

>Este capítulo discute a arquitetura x86 / IA-32 conforme definida no Intel 64 e IA-32 Architectures Software Developer’s
Manual, Volumes 1–3 (www.intel.com/content/www/us/en/processors/architectures-software-developermanuals.html)



## Registers Set and Data Types ( registradores e tipos de dados)



**GPRs - General Porpouse Registers** - registradores de uso geral

Ao operar em modo protegido, a arquitetura x86 fornece 8 registradores de uso geral (GPRs) de 32 bits. São eles: **EAX, EBX, ECX, EDX, EDI, ESI, EBP, and ESP**.
Alguns destes podem ser subdividios em registradores de 16 ou 8 bits. Exemplo : **EAX = 32 bits / AX = 16 bits AL ou AH = 8 bits**


![Imgur](https://i.imgur.com/IGbt60P.png)



_Alguns registradores e seus objetivos de origem_:


Registrador | Objetivo
------------| ----------------------------------------------------
ECX 	    | usado como contador nas implementações de loop
ESI         | usado como origem em operações com strings/memory
EDI         | usado como destino em operações com strings/memory
EBP         | Base frame pointer
ESP			| Stack pointer



Tipos de dados, e suas nomeclaturas mais cumuns :


- BYTE (8 bits)

		Ex : AL,BL,AH,BH

- WORD (16 bits)

		Ex : AX,BX,SI

- DWORD (32 bits)

		Ex : EAX,EBX,EDI

- QWORD (64 bits)

Embora o **x86** não tenha GPRs de 64 bits, ele pode combinar dois registradores, tipo( EDX:EAX ), e tratá-los como valores de 64 bits em alguns cenários; por exemplo usando a instrução [RDTSC](https://docs.microsoft.com/pt-br/cpp/intrinsics/
rdtsc?view=msvc-160) é possível gravar um valor de 64 bits em EDX:EAX


O Instruction Pointer(ponteiro p/ próxima instrução), tem um registrador padrão que guarda o endereço da próxima instrução :

		EIP = 32 bits

O registrador **EFLAGS** de 32 bits é usado para armazenar o status de operações aritméticas e outros estados de
execução. Quando a instrução anterior resultar em zero, **ZF**(Zero Flag, que é uma das flags mais importantes do EFLAGS)
será definida como 1. As flags de EFLAGS são usados principalmente para implementar ramificação condicionais.

		EFLAGS = 32 bits / cada bit = 1 FLAG

Além dos GPRs, EIP e EFLAGS, também existem registradores que controlam mecanismos importantes do sistema de low-level,como
virtual memory, interrupts e degugging. Por exemplo :

		CR0 = controla se a paginação está ativada ou desativada
		CR2 = contém o endereço linear que causou uma falha de página
		CR3 = é o endereço base de uma estrutura de dados de paginação
		CR4 = controla as configurações de virtualização de hardware.

		DR0 – DR7 =  são usados por Memory Breakpoints.
		Voltaremos a esses registradores mais tarde na seção “Mecanismo do sistema”.

_NOTE: Embora haja sete registradores de debugging, o sistema permite apenas quatro Memory BreakPoints (DR0-DR3).
Os registradores restantes são usados para validar status._


Existem também registradores específicos do modelo (MSRs). Como o nome indica, esses registradores podem variar entre os
diferentes processadores da Intel e AMD. Cada MSR é identificado por nome e um número de 32 bits, e é lido/escrito por meio
das instruções RDMSR/WRMSR. Eles são acessíveis apenas ao código rodando em ring 0 e normalmente são usados para armazenar
contadores especiais e implementar funcionalidade de low-level. Por exemplo, a instrução assembly *SYSENTER* transfere a
execução para o endereço armazenado no IA32_SYSENTER_EIP MSR (0x176), que geralmente é o manipulador das chamadas de sistema
(systemsCalls). MSRs são discutidos ao longo do livro à medida que aparecem.



## Instrutions Set ( conjunto de instruções )



O conjunto de instruções que o **x86** fornece, são bem flexivéis em termos de movimentação de dados entre registradores e memória.
Essa movimentação de dados, pode ser classificada em 5 tipos :

- Imediato p/ Registrador
- Registrador p/ Registrador
- Imediato p/ Memória
- Registrador p/ Memória e vice-versa
- Memória p/ Memória


Os primeiros quatro métodos são suportados por todas as arquiteturas modernas, mas o último é específico para x86.
Uma arquitetura RISC clássica como ARM só pode _LER/ESCREVER_ dados de/para memória com instruções de __load/store__. A instrução LDR and STR respectiva. Por exemplo uma operação simples como incrementar um valor na memória requer 3 instruções :

 1. Ler dados da memória para um registrador (LDR).
 2. Adicionar 1 ao registrador (ADD).
 3. Gravar o registrador na memória (STR)

No x86, tal operação exigiria apenas uma instrução (INC ou ADD) porque pode acessar a memória diretamente. A instrução MOVS
pode ler e escrever na memória ao mesmo tempo. Veja os exemplos :


**ARM**


	01: 1B 68 LDR R3, [R3] ; read the value at address R3
	02: 5A 1C ADDS R2, R3, #1 ; add 1 to it
	03: 1A 60 STR R2, [R3] ; write updated value back to address R3


**x86**


	01: FF 00 inc dword ptr [eax]
	; directly increment value at address EAX


Outra característica importante é que o **x86** usa o tamanho de instruções de comprimento variável: no o comprimento da instrução pode variar de 1 a 15 bytes. No **ARM**, as instruções têm 2 ou 4 bytes de comprimento.



Sintaxe
---------



Dependendo o assembler/disassembler, existem 2 variações de sintaxe da linguagem assembly x86 : __Intel ou AT&__ .


**Intel**


	mov ecx, AABBCCDDh
	mov ecx, [eax]
	mov ecx, eax


**AT&T**


	movl $0xAABBCCDD, %ecx
	movl (%eax), %ecx
	movl %eax, %ecx


É importante observar que essas são as mesmas instruções, mas escritas em sintaxes diferentes. Existem várias
diferenças entre a notação Intel e AT&T, mas as mais notáveis são as seguintes:


- A AT&T prefixa os registradores com *%* e imediatos com *$*. Intel não faz isso.

- A AT&T adiciona um prefixo à instrução para indicar a largura da operação. Por exemplo, MOVL (long), MOVB (byte),
etc.. A Intel não faz isso.

- A AT&T coloca o operando de origem antes do destino. A Intel inverte a ordem.


Disassemblers/Assemblers e outras ferramentas de engenharia reversa (IDA Pro, OllyDbg, MASM, etc.) no Windows geralmente usam a notação __Intel__, enquanto aqueles no UNIX frequentemente seguem a notação __AT&T__ (GCC). Na prática, a notação Intel é a forma dominante e é usada ao longo deste livro.



## Data Movement ( Movendo dados)



As instruções operam com valores que vem de registradores ou da main memory. A instrução mais comum
para mover dados é a instrução *MOV*.Exemplo de uso simples: mover um registrador ou um imediato para um
registrador. Por exemplo:

		01: BE 3F 00 0F 00 mov esi, 0F003Fh 	; set ESI = 0xF003
		02: 8B F1 		   mov esi, ecx     	; set ESI = ECX

O próximo uso comum é mover dados _DE/PARA_ memória. Semelhante a outras convenções da linguagem assembly o **x86** usa o Colchetes __[]__ para indicar acesso na memória. ( a única exceção é a instrução LEA, que usa os [ ] mas na verdade não faz referência a memória) O acesso a memória pode ser especificado de meneiras diferentes, portando começaremos com o caso mais simples :

*Assembly - código 0x00*

	01: C7 00 01 00 00+ 	mov dword ptr [eax], 1 	; mover 0x01 p/ offset de memória de EAX.
	02: 8B 08 				mov ecx, [eax] 		   	; mover p/ registrador ECX o valor contido no offset de memória de EAX
	03: 89 18 				mov [eax], ebx         	; mover p/ offset de memória de EAX o valor contido no registrador EBX
	04: 89 46 34 			mov [esi+34h], eax     	; mover p/ offset de (ESI+34) o valor do registrador EAX
	05: 8B 46 34 			mov eax, [esi+34h]     	; mover p/ registrador EAX o valor do offset de memória de (EAX+34)
	06: 8B 14 01 			mov edx, [ecx+eax]     	; mover p/ registrador EDX o valor do offset de memória de (ECX+EAX)


*Pseudo C*

	01: *eax = 1;
	02: ecx = *eax;
	03: *eax = ebx;
	04: *(esi+34) = eax;
	05: eax = *(esi+34);
	06: edx = *(ecx+eax);


Esses exemplos demonstram o acesso à memória por meio de um registrador base e um offset , onde o offset pode ser um registrador ou um operadando imediato. Essa forma é comumente usada para acessar itens das structs ou buffers de dados em um local calculado em tempo de execução.Por exemplo,suponha Wx''que *ECX* aponte para uma struct do tipo _KDPC_ com o seguinte layout :

	kd> dt nt!_KDPC
		 +0x000 Type : UChar
		 +0x001 Importance : UChar
		 +0x002 Number : Uint2B
		 +0x004 DpcListEntry : _LIST_ENTRY
		 +0x00c DeferredRoutine : Ptr32 void
		 +0x010 DeferredContext : Ptr32 Void
		 +0x014 SystemArgument1 : Ptr32 Void
		 +0x018 SystemArgument2 : Ptr32 Void
		 +0x01c DpcData : Ptr32 Void


E usado no seguinte contexto:

*Assembly - código 0x01*

	01: 8B 45 0C 		mov eax, [ebp+0Ch]
	02: 83 61 1C 00 	and dword ptr [ecx+1Ch], 0
	03: 89 41 0C 		mov [ecx+0Ch], eax
	04: 8B 45 10 		mov eax, [ebp+10h]
	05: C7 01 13 01 00+ mov dword ptr [ecx], 113h
	06: 89 41 10 		mov [ecx+10h], eax

*Pseudo C*

	KDPC *p = ...; 00?
	p->DpcData = NULL; 02!
	p->DeferredRoutine = ... ;03!
	*(int *)p = 0x113; 05?
	p->DeferredContext = ...; 06!


- A linha 1 lê um valor da memória e o armazena no registrador **EAX**. 
- O campo __DeferredRoutine__ é definido com este valor na linha 3. 
- A linha 2 limpa o campo __DpcData__ usando o operador **AND** com 0. 
- A linha 4 lê outro valor da memória e armazena em **EAX** 
- E por fim o campo __DeferredContext__ é definido com o último valor guardado em *EAX*.

- A linha 5 escreve uma DWORD com valor 0x113 na base da struct. Como ele escreve uma DWORD na base, se o primeiro
campo da struct tem apenas 1 BYTE de tamanho? Isso não definirá implicitamente os campos __Importance e Number__ ?
a RESPOSTA é sim! abaixo vemos o número 0x113 ser convertido pra binary pra ficar mais claro:


![Figure 1-2](https://i.imgur.com/1ULMDI4.png)

	
O campo "Type" é definido como 0x13 (bits em negrito), "Importance" é definido como 0x1 (bits itálicos) e Number é definido como 0x0
(o resto dos bits da DWORD). Ao escrever um valor, o código conseguiu inicializar três campos com uma única instrução! O código também
poderia estar escrito da seguinte forma:

*Assembly - código 0x02*

		01: 8B 45 0C mov eax, [ebp+0Ch]
		02: 83 61 1C 00 and dword ptr [ecx+1Ch], 0
		03: 89 41 0C mov [ecx+0Ch], eax
		04: 8B 45 10 mov eax, [ebp+10h]
		05: C6 01 13 mov byte ptr [ecx],13h
		06: C6 41 01 01 mov byte ptr [ecx+1],1
		07: 66 C7 41 02 00+ mov word ptr [ecx+2],0
		08: 89 41 10 mov [ecx+10h], eax

PS: _Agora a instrução que antes foi executada apenas na linha 5, está desmebrada em três linhas : 5,6,7_

O compilador decidiu juntar três instruções em uma, porque conhecia as constantes com antecedência e quis economizar espaço. A versão
de três instruções separadas ocupam 13 bytes (o byte extra na linha 7 não é mostrado), enquanto a versão de uma instrução ocupa 6 bytes
Outra observação interessante é que o acesso à memória pode ser feito em três níveis de granularidade: 

		BYTE, WORD, DWORD

O padrão sempre é 4 bytes (DWORD) , podendo ser alterada para 1 byte ou 2 bytes(WORD) usando um prefixo de substituição.
No exemplo, os bytes do prefixo de substituição são C6 e 66 (dos exemplos acima). Outros prefixos são discutidos à medida que aparecem.


A próxima forma de acesso à memória é comumente usada para acessar objetos do tipo array. Geralmente, o formato é o seguinte:

		[Base + Index *scale]

Isso é melhor compreendido por meio de exemplos e prática:


		01: 8B 34 B5 40 05+ mov esi, _KdLogBuffer[esi*4]

		; normalemente escrito assim:  mov esi, [_KdLogBuffer + esi * 4]
		; _KdLogBuffer é o Base address de uma array global e
		; ESI é o Index; sabemos que cada elemento da array
		; tem 4 bytes de comprimento (daí o fator de scale como = * x4)

		02: 89 04 F7 mov [edi+esi*8], eax
		; Aqui temos o EDI como o base address, ESI como o índice da array e o tamanho do scale é 0x08


Na prática, isso pode ser observado em um loop de código em uma array. Por exemplo:

*Assembly - código 0x03*

		01: loop_start:
		02: 8B 47 04 mov eax, [edi+4]
		03: 8B 04 98 mov eax, [eax+ebx*4]
		04: 85 C0 test eax, eax
		...
		05: 74 14 jz short loc_7F627F
		06: loc_7F627F:
		07: 43 inc ebx
		08: 3B 1F cmp ebx, [edi]
		09: 7C DD jl short loop_start


- Na linha 2 lê uma DWORD do offset EDI + 4 e então a usa como o Base address em um array 
- Na linha 3. Portanto, você sabe que o **EDI** é provavelmente uma struct que tem um array no offset "+4". 
- Na linha 7 incrementa o Index. 
- Na linha 8 compara o Index com o offset do Base Address da struct.

Com essas informações, esse pequeno loop pode ser decompilado da seguinte maneira:


		typedef struct _FOO
		{
		 DWORD size; // +0x00
		 DWORD array[...]; // +0x04
		} FOO, *PFOO;
		PFOO bar = ...;
		for (i = ...; i < bar->size; i++) {
		 if (bar->array[i] != 0) {
		 ...
		 }	
		}



As instruções **MOVSB ​​/ MOVSW / MOVSD** movem dados com granularidade de 1, 2 ou 4 bytes entre dois endereços de memória. E
respectivamente essas instruções usam implicitamente os registradores **EDI / ESI** como os endereços de DESTINO/ORIGEM.
Além disso, eles também atualizam automaticamente o endereço de DESTINO/ORIGEM dependendo da flag de direção (DF) flag de
EFLAGS.

Se **DF** for 0, os endereços são decrementados e caso contrário são incrementados. Essas instruções normalmente são usadas para
implementar funções de String ou funções que copiam Memória quando o comprimento/largura é conhecido em tempo de compilação. Em alguns
casos são acompanhados pelo prefixo _RET_, que repete uma instrução até **ECX** vezes. Considere o seguinte exemplo :


*Assembly - código 0x04*

		01: BE 28 B5 41 00 mov esi, offset _RamdiskBootDiskGuid
		; ESI = ponteiro para RamdiskBootDiskGuid
		02: 8D BD 40 FF FF+ lea edi, [ebp-0C0h]
		; EDI é um endereço em algum lugar da pilha
		03: A5 movsd
		; copies 4 bytes from EDI to ESI; increment cada um por 4
		04: A5 movsd
		; o mesmo que acima
		05: A5 movsd
		; o mesmo que acima
		06: A5 movsd
		; o mesmo que acima


*Pseudo C*

		/* a GUID is 16-byte structure */
		GUID RamDiskBootDiskGuid = ...; // global
		...
		GUID foo;
		memcpy(&foo, &RamdiskBootDiskGuid, sizeof(GUID));



A line 2 merece uma atenção especial. Embora a instrução **LEA** use [], na verdade não lê de um memory address; simplesmente avalia a
expressão entre colchetes e coloca o resultado no registrador de destino(DEST). Por exemplo, se EBP fosse 0x1000, então EDI seria:

		0xF40 (= 0x1000 - 0xC0)

Depois de executar a linha 2. O ponto é que LEA não acessa a memória, apesar a sintaxe enganosa. O exemplo a seguir, de 
**nt!KiInitSystem**, usa o prefixo REP.. vamos ver:


*Assembly - código 0x05*


		01: 6A 08 push 8 ; push 8 on the stack (irá ser explicado ao falar das stacks)
		02: ...
		03: 59 pop ecx ; pop the stack. Basically sets ECX to 8.
		04: ...
		05: BE 00 44 61 00 mov esi, offset _KeServiceDescriptorTable
		06: BF C0 43 61 00 mov edi, offset _KeServiceDescriptorTableShadow
		07: F3 A5 rep movsd ; copy 32 bytes (movsd repete 8 vezes)
		; a partir disso, podemos deduzir que sejam quais forem esses dois objetos, eles terão
		; provavelmente 32 bytes de tamanho.


*Pseudo C*


		memcpy(&KeServiceDescriptorTableShadow, &KeServiceDescriptorTable, 32);


Agora o exemplo final, a **nt!MmInitializeProcessAddressSpace** usa uma combinação variada dessas instruções, devido a cópia não ser
múltipla de 4 bytes :

*Assembly - código 0x06*

		01: 8D B0 70 01 00+ lea esi, [eax+170h]
		; EAX é provavelmente o endereço básico de uma struct. Lembre-se do que dissemos
		; sobre LEA..
		02: 8D BB 70 01 00+ lea edi, [ebx+170h]
		; EBX provavelmente é outra struct do mesmo tipo
		03: A5 movsd
		04: A5 movsd
		05: A5 movsd
		06: 66 A5 movsw
		07: A4 movsb


Depois das linhas 1–2, você sabe que EAX e EBX provavelmente são do mesmo tipo porque estão sendo usados como origem / destino e os
offsets são iguais. Este trecho de código simplesmente copia 15 bytes de um campo de uma struct p/ outra. Notamos que o código também
poderia ser escrito usando a instrução **MOVSB** com um prefixo **REP** e o **ECX**(counter) definido como 15; Entretanto isso seria
ineficiente pois resultaria em 15 leituras em vez de apanas 5.

Outra classe de instrução que movimenta dados com origem/destino implícitos inclui as instruções : **SCAS** e **STOS** . Semelhante aos _MOVS_, essas instruções podem operar em granulalidade de 1,2 ou 4 bytes.

**SCAS** compara implicitamente : __AL / AX / EAX__ com dados que começam no endereço de memória de EDI. EDI é decrementado/incrementado automaticamente dependendo da **DF** flag. Devido à sua semântica, o **SCAS** é comumente usado junto com o prefixo REP para encontrar um byte, word ou dword em um buffer. Por exemplo, a função C strlen () pode ser implementada da seguinte forma:

*Assembly - código 0x07*

		01: 30 C0 xor al, al
		; setando AL p/ 0 (NUL byte).Veremos frequentemente a instrução : XOR reg, reg
		; pattern in code para zerar o valor do registrador.
		02: 89 FB mov ebx, edi
		; save the original pointer to the string
		03: F2 AE repne scasb
		; avance repetidamente um byte de cada vez, desde que AL não corresponda ao
		; byte em EDI, quando esta instrução terminar significa que alcançamos o byte NUL no buffer de string.
		04: 29 DF sub edi, ebx
		; edi agora é onde está o NUL byte location. Subtraia isso do ponteiro original
		; para o tamanho



**STOS** é o mesmo que **SCAS**, exceto que grava o valor de __AL / AX / EAX__  em EDI. Isso é constantemente usado para inicializar um buffer com um valor constante(como memset()). Aqui está um exemplo :

*Assembly - código 0x08*

		01: 33 C0 xor eax, eax
		; set EAX to 0
		02: 6A 09 push 9
		; push 9 on the stack
		03: 59 pop ecx
		; pop it back in ECX. Now ECX = 9.
		04: 8B FE mov edi, esi
		; set the destination address
		05: F3 AB rep stosd
		; write 36 bytes of zero to the destination buffer (STOSD repeated 9 times)
		; this is equivalent lent to memset(edi, 0, 36)


Observação : **LODS** é outra instrução da mesma família. Ela lê um valor de 1, 2 ou 4 bytes do ESI e o armazena em AL, AX ou EAX.



EXERCISE 0x01 = STOPED
------------------------





