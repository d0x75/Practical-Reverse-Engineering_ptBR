[Previous](../intro.md)
------------------------


# Capítulo 0x01 - x86 and x64



O x86 é a arquitetura little-endian baseada no processador Intel 8086. Para o propósito de nosso capítulo, x86 é a implementação de 32 bits da arquitetura Intel (IA-32), conforme definido no Intel Software Development Manual. De um modo geral,o IA-32 pode operar em dois modos: *real e protegido*. O modo real é o estado do processador quando é ligado pela primeira vez e suporta apenas um conjunto de instruções de 16 bits. O modo protegido é o estado do processador com suporte para memória virtual, paginação e outros recursos; é o estado em que os sistemas operacionais modernos são executados. A extensão de 64 bits da arquitetura é chamada de x64 ou x86-64. Este capítulo discute o **x86** operando em modo protegido.


O x86 oferece suporte ao conceito de separação de privilégios por meio duma abstração conhecida como Ring Level. O processador
suporta quatro ring levels, numerados de 0 a 3.(Os rings 1 e 2 não são comumente usados/conhecidos, portanto não são discutidos
aqui.) O __Ring 0__ é o nível que possui privilégio mais alto e pode modificar todas as configurações do sistema.O __Ring 3__ é o nível
de privilégios mais baixo e só pode ler/modificar um subconjunto das configurações do sistema. Portanto,sistemas operacionais
modernos geralmente implementam a separação de privilégios de user/kernel por ter aplicativos em user-mode executados
no Ring 3 e os de kernel-mode no Ring 0. O __ring revel__ é codificado no registrador **CS** e às vezes referido como o nível de
privilégio atual (CPL) na documentação oficial.

>Este capítulo discute a arquitetura x86 / IA-32 conforme definida no Intel 64 e IA-32 Architectures Software Developer’s
Manual, Volumes 1–3 (www.intel.com/content/www/us/en/processors/architectures-software-developermanuals.html)



## Registers Set and Data Types ( registradores e tipos de dados)



**GPRs - General Porpouse Registers** - registradores de uso geral

Ao operar em modo protegido, a arquitetura x86 fornece 8 registradores de uso geral (GPRs) de 32 bits. São eles: **EAX, EBX, ECX, EDX, EDI, ESI, EBP, and ESP**.
Alguns destes podem ser subdividios em registradores de 16 ou 8 bits. Exemplo : **EAX = 32 bits / AX = 16 bits AL ou AH = 8 bits**


![Imgur](https://i.imgur.com/IGbt60P.png)



_Alguns registradores e seus objetivos de origem_:


Registrador | Objetivo
------------| ----------------------------------------------------
ECX 	    | usado como contador nas implementações de loop
ESI         | usado como origem em operações com strings/memory
EDI         | usado como destino em operações com strings/memory
EBP         | Base frame pointer
ESP			| Stack pointer



Tipos de dados, e suas nomeclaturas mais cumuns :


- BYTE (8 bits)

		Ex : AL,BL,AH,BH

- WORD (16 bits)

		Ex : AX,BX,SI

- DWORD (32 bits)

		Ex : EAX,EBX,EDI

- QWORD (64 bits)

Embora o **x86** não tenha GPRs de 64 bits, ele pode combinar dois registradores, tipo( EDX:EAX ), e tratá-los como valores de 64 bits em alguns cenários; por exemplo usando a instrução [RDTSC](https://docs.microsoft.com/pt-br/cpp/intrinsics/
rdtsc?view=msvc-160) é possível gravar um valor de 64 bits em EDX:EAX


O Instruction Pointer(ponteiro p/ próxima instrução), tem um registrador padrão que guarda o endereço da próxima instrução :

		EIP = 32 bits

O registrador **EFLAGS** de 32 bits é usado para armazenar o status de operações aritméticas e outros estados de
execução. Quando a instrução anterior resultar em zero, **ZF**(Zero Flag, que é uma das flags mais importantes do EFLAGS)
será definida como 1. As flags de EFLAGS são usados principalmente para implementar ramificação condicionais.

		EFLAGS = 32 bits / cada bit = 1 FLAG

Além dos GPRs, EIP e EFLAGS, também existem registradores que controlam mecanismos importantes do sistema de low-level,como
virtual memory, interrupts e degugging. Por exemplo :

		CR0 = controla se a paginação está ativada ou desativada
		CR2 = contém o endereço linear que causou uma falha de página
		CR3 = é o endereço base de uma estrutura de dados de paginação
		CR4 = controla as configurações de virtualização de hardware.

		DR0 – DR7 =  são usados por Memory Breakpoints.
		Voltaremos a esses registradores mais tarde na seção “Mecanismo do sistema”.

_NOTE: Embora haja sete registradores de debugging, o sistema permite apenas quatro Memory BreakPoints (DR0-DR3).
Os registradores restantes são usados para validar status._


Existem também registradores específicos do modelo (MSRs). Como o nome indica, esses registradores podem variar entre os
diferentes processadores da Intel e AMD. Cada MSR é identificado por nome e um número de 32 bits, e é lido/escrito por meio
das instruções RDMSR/WRMSR. Eles são acessíveis apenas ao código rodando em ring 0 e normalmente são usados para armazenar
contadores especiais e implementar funcionalidade de low-level. Por exemplo, a instrução assembly *SYSENTER* transfere a
execução para o endereço armazenado no IA32_SYSENTER_EIP MSR (0x176), que geralmente é o manipulador das chamadas de sistema
(systemsCalls). MSRs são discutidos ao longo do livro à medida que aparecem.



## Instrutions Set ( conjunto de instruções )



O conjunto de instruções que o **x86** fornece, são bem flexivéis em termos de movimentação de dados entre registradores e memória.
Essa movimentação de dados, pode ser classificada em 5 tipos :

- Imediato p/ Registrador
- Registrador p/ Registrador
- Imediato p/ Memória
- Registrador p/ Memória e vice-versa
- Memória p/ Memória


Os primeiros quatro métodos são suportados por todas as arquiteturas modernas, mas o último é específico para x86.
Uma arquitetura RISC clássica como ARM só pode _LER/ESCREVER_ dados de/para memória com instruções de __load/store__. A instrução LDR and STR respectiva. Por exemplo uma operação simples como incrementar um valor na memória requer 3 instruções :

 1. Ler dados da memória para um registrador (LDR).
 2. Adicionar 1 ao registrador (ADD).
 3. Gravar o registrador na memória (STR)

No x86, tal operação exigiria apenas uma instrução (INC ou ADD) porque pode acessar a memória diretamente. A instrução MOVS
pode ler e escrever na memória ao mesmo tempo. Veja os exemplos :


**ARM**


	01: 1B 68 LDR R3, [R3] ; read the value at address R3
	02: 5A 1C ADDS R2, R3, #1 ; add 1 to it
	03: 1A 60 STR R2, [R3] ; write updated value back to address R3


**x86**


	01: FF 00 inc dword ptr [eax]
	; directly increment value at address EAX


Outra característica importante é que o **x86** usa o tamanho de instruções de comprimento variável: no o comprimento da instrução pode variar de 1 a 15 bytes. No **ARM**, as instruções têm 2 ou 4 bytes de comprimento.



Sintaxe
---------



Dependendo o assembler/disassembler, existem 2 variações de sintaxe da linguagem assembly x86 : __Intel ou AT&__ .


**Intel**


	mov ecx, AABBCCDDh
	mov ecx, [eax]
	mov ecx, eax


**AT&T**


	movl $0xAABBCCDD, %ecx
	movl (%eax), %ecx
	movl %eax, %ecx


É importante observar que essas são as mesmas instruções, mas escritas em sintaxes diferentes. Existem várias
diferenças entre a notação Intel e AT&T, mas as mais notáveis são as seguintes:


- A AT&T prefixa os registradores com *%* e imediatos com *$*. Intel não faz isso.

- A AT&T adiciona um prefixo à instrução para indicar a largura da operação. Por exemplo, MOVL (long), MOVB (byte),
etc.. A Intel não faz isso.

- A AT&T coloca o operando de origem antes do destino. A Intel inverte a ordem.


Disassemblers/Assemblers e outras ferramentas de engenharia reversa (IDA Pro, OllyDbg, MASM, etc.) no Windows geralmente usam a notação __Intel__, enquanto aqueles no UNIX frequentemente seguem a notação __AT&T__ (GCC). Na prática, a notação Intel é a forma dominante e é usada ao longo deste livro.



## Data Movement ( Movendo dados)



As instruções operam com valores que vem de registradores ou da main memory. A instrução mais comum
para mover dados é a instrução *MOV*.Exemplo de uso simples: mover um registrador ou um imediato para um
registrador. Por exemplo:

		01: BE 3F 00 0F 00 mov esi, 0F003Fh 	; set ESI = 0xF003
		02: 8B F1 		   mov esi, ecx     	; set ESI = ECX

O próximo uso comum é mover dados _DE/PARA_ memória. Semelhante a outras convenções da linguagem assembly o **x86** usa o Colchetes __[]__ para indicar acesso na memória. ( a única exceção é a instrução LEA, que usa os [ ] mas na verdade não faz referência a memória) O acesso a memória pode ser especificado de meneiras diferentes, portando começaremos com o caso mais simples :

*Assembly - código 0x00*

	01: C7 00 01 00 00+ 	mov dword ptr [eax], 1 	; mover 0x01 p/ offset de memória de EAX.
	02: 8B 08 				mov ecx, [eax] 		   	; mover p/ registrador ECX o valor contido no offset de memória de EAX
	03: 89 18 				mov [eax], ebx         	; mover p/ offset de memória de EAX o valor contido no registrador EBX
	04: 89 46 34 			mov [esi+34h], eax     	; mover p/ offset de (ESI+34) o valor do registrador EAX
	05: 8B 46 34 			mov eax, [esi+34h]     	; mover p/ registrador EAX o valor do offset de memória de (EAX+34)
	06: 8B 14 01 			mov edx, [ecx+eax]     	; mover p/ registrador EDX o valor do offset de memória de (ECX+EAX)


*Pseudo C*

	01: *eax = 1;
	02: ecx = *eax;
	03: *eax = ebx;
	04: *(esi+34) = eax;
	05: eax = *(esi+34);
	06: edx = *(ecx+eax);


Esses exemplos demonstram o acesso à memória por meio de um registrador base e um offset , onde o offset pode ser um registrador ou um operadando imediato. Essa forma é comumente usada para acessar itens das structs ou buffers de dados em um local calculado em tempo de execução.Por exemplo,suponha Wx''que *ECX* aponte para uma struct do tipo _KDPC_ com o seguinte layout :

	kd> dt nt!_KDPC
		 +0x000 Type : UChar
		 +0x001 Importance : UChar
		 +0x002 Number : Uint2B
		 +0x004 DpcListEntry : _LIST_ENTRY
		 +0x00c DeferredRoutine : Ptr32 void
		 +0x010 DeferredContext : Ptr32 Void
		 +0x014 SystemArgument1 : Ptr32 Void
		 +0x018 SystemArgument2 : Ptr32 Void
		 +0x01c DpcData : Ptr32 Void


E usado no seguinte contexto:

*Assembly - código 0x01*

	01: 8B 45 0C 		mov eax, [ebp+0Ch]
	02: 83 61 1C 00 	and dword ptr [ecx+1Ch], 0
	03: 89 41 0C 		mov [ecx+0Ch], eax
	04: 8B 45 10 		mov eax, [ebp+10h]
	05: C7 01 13 01 00+ mov dword ptr [ecx], 113h
	06: 89 41 10 		mov [ecx+10h], eax

*Pseudo C*

	KDPC *p = ...; 00?
	p->DpcData = NULL; 02!
	p->DeferredRoutine = ... ;03!
	*(int *)p = 0x113; 05?
	p->DeferredContext = ...; 06!


- A linha 1 lê um valor da memória e o armazena no registrador **EAX**. 
- O campo __DeferredRoutine__ é definido com este valor na linha 3. 
- A linha 2 limpa o campo __DpcData__ usando o operador **AND** com 0. 
- A linha 4 lê outro valor da memória e armazena em **EAX** 
- E por fim o campo __DeferredContext__ é definido com o último valor guardado em *EAX*.

- A linha 5 escreve uma DWORD com valor 0x113 na base da struct. Como ele escreve uma DWORD na base, se o primeiro
campo da struct tem apenas 1 BYTE de tamanho? Isso não definirá implicitamente os campos __Importance e Number__ ?
a RESPOSTA é sim! abaixo vemos o número 0x113 ser convertido pra binary pra ficar mais claro:


![Figure 1-2](https://i.imgur.com/1ULMDI4.png)

	
O campo "Type" é definido como 0x13 (bits em negrito), "Importance" é definido como 0x1 (bits itálicos) e Number é definido como 0x0
(o resto dos bits da DWORD). Ao escrever um valor, o código conseguiu inicializar três campos com uma única instrução! O código também
poderia estar escrito da seguinte forma:

*Assembly - código 0x02*

		01: 8B 45 0C mov eax, [ebp+0Ch]
		02: 83 61 1C 00 and dword ptr [ecx+1Ch], 0
		03: 89 41 0C mov [ecx+0Ch], eax
		04: 8B 45 10 mov eax, [ebp+10h]
		05: C6 01 13 mov byte ptr [ecx],13h
		06: C6 41 01 01 mov byte ptr [ecx+1],1
		07: 66 C7 41 02 00+ mov word ptr [ecx+2],0
		08: 89 41 10 mov [ecx+10h], eax

PS: _Agora a instrução que antes foi executada apenas na linha 5, está desmebrada em três linhas : 5,6,7_

O compilador decidiu juntar três instruções em uma, porque conhecia as constantes com antecedência e quis economizar espaço. A versão
de três instruções separadas ocupam 13 bytes (o byte extra na linha 7 não é mostrado), enquanto a versão de uma instrução ocupa 6 bytes
Outra observação interessante é que o acesso à memória pode ser feito em três níveis de granularidade: 

		BYTE, WORD, DWORD

O padrão sempre é 4 bytes (DWORD) , podendo ser alterada para 1 byte ou 2 bytes(WORD) usando um prefixo de substituição.
No exemplo, os bytes do prefixo de substituição são C6 e 66 (dos exemplos acima). Outros prefixos são discutidos à medida que aparecem.


A próxima forma de acesso à memória é comumente usada para acessar objetos do tipo array. Geralmente, o formato é o seguinte:

		[Base + Index *scale]

Isso é melhor compreendido por meio de exemplos e prática:


		01: 8B 34 B5 40 05+ mov esi, _KdLogBuffer[esi*4]

		; normalemente escrito assim:  mov esi, [_KdLogBuffer + esi * 4]
		; _KdLogBuffer é o Base address de uma array global e
		; ESI é o Index; sabemos que cada elemento da array
		; tem 4 bytes de comprimento (daí o fator de scale como = * x4)

		02: 89 04 F7 mov [edi+esi*8], eax
		; Aqui temos o EDI como o base address, ESI como o índice da array e o tamanho do scale é 0x08


Na prática, isso pode ser observado em um loop de código em uma array. Por exemplo:

*Assembly - código 0x03*

		01: loop_start:
		02: 8B 47 04 mov eax, [edi+4]
		03: 8B 04 98 mov eax, [eax+ebx*4]
		04: 85 C0 test eax, eax
		...
		05: 74 14 jz short loc_7F627F
		06: loc_7F627F:
		07: 43 inc ebx
		08: 3B 1F cmp ebx, [edi]
		09: 7C DD jl short loop_start


- Na linha 2 lê uma DWORD do offset EDI + 4 e então a usa como o Base address em um array 
- Na linha 3. Portanto, você sabe que o **EDI** é provavelmente uma struct que tem um array no offset "+4". 
- Na linha 7 incrementa o Index. 
- Na linha 8 compara o Index com o offset do Base Address da struct.

Com essas informações, esse pequeno loop pode ser decompilado da seguinte maneira:


		typedef struct _FOO
		{
		 DWORD size; // +0x00
		 DWORD array[...]; // +0x04
		} FOO, *PFOO;
		PFOO bar = ...;
		for (i = ...; i < bar->size; i++) {
		 if (bar->array[i] != 0) {
		 ...
		 }	
		}



As instruções **MOVSB ​​/ MOVSW / MOVSD** movem dados com granularidade de 1, 2 ou 4 bytes entre dois endereços de memória. E
respectivamente essas instruções usam implicitamente os registradores **EDI / ESI** como os endereços de DESTINO/ORIGEM.
Além disso, eles também atualizam automaticamente o endereço de DESTINO/ORIGEM dependendo da flag de direção (DF) flag de
EFLAGS.

Se **DF** for 0, os endereços são decrementados e caso contrário são incrementados. Essas instruções normalmente são usadas para
implementar funções de String ou funções que copiam Memória quando o comprimento/largura é conhecido em tempo de compilação. Em alguns
casos são acompanhados pelo prefixo _RET_, que repete uma instrução até **ECX** vezes. Considere o seguinte exemplo :


*Assembly - código 0x04*

		01: BE 28 B5 41 00 mov esi, offset _RamdiskBootDiskGuid
		; ESI = ponteiro para RamdiskBootDiskGuid
		02: 8D BD 40 FF FF+ lea edi, [ebp-0C0h]
		; EDI é um endereço em algum lugar da pilha
		03: A5 movsd
		; copies 4 bytes from EDI to ESI; increment cada um por 4
		04: A5 movsd
		; o mesmo que acima
		05: A5 movsd
		; o mesmo que acima
		06: A5 movsd
		; o mesmo que acima


*Pseudo C*

		/* a GUID is 16-byte structure */
		GUID RamDiskBootDiskGuid = ...; // global
		...
		GUID foo;
		memcpy(&foo, &RamdiskBootDiskGuid, sizeof(GUID));



A line 2 merece uma atenção especial. Embora a instrução **LEA** use [], na verdade não lê de um memory address; simplesmente avalia a
expressão entre colchetes e coloca o resultado no registrador de destino(DEST). Por exemplo, se EBP fosse 0x1000, então EDI seria:

		0xF40 (= 0x1000 - 0xC0)

Depois de executar a linha 2. O ponto é que LEA não acessa a memória, apesar a sintaxe enganosa. O exemplo a seguir, de 
**nt!KiInitSystem**, usa o prefixo REP.. vamos ver:


*Assembly - código 0x05*


		01: 6A 08 push 8 ; push 8 on the stack (irá ser explicado ao falar das stacks)
		02: ...
		03: 59 pop ecx ; pop the stack. Basically sets ECX to 8.
		04: ...
		05: BE 00 44 61 00 mov esi, offset _KeServiceDescriptorTable
		06: BF C0 43 61 00 mov edi, offset _KeServiceDescriptorTableShadow
		07: F3 A5 rep movsd ; copy 32 bytes (movsd repete 8 vezes)
		; a partir disso, podemos deduzir que sejam quais forem esses dois objetos, eles terão
		; provavelmente 32 bytes de tamanho.


*Pseudo C*


		memcpy(&KeServiceDescriptorTableShadow, &KeServiceDescriptorTable, 32);


Agora o exemplo final, a **nt!MmInitializeProcessAddressSpace** usa uma combinação variada dessas instruções, devido a cópia não ser
múltipla de 4 bytes :

*Assembly - código 0x06*

		01: 8D B0 70 01 00+ lea esi, [eax+170h]
		; EAX é provavelmente o endereço básico de uma struct. Lembre-se do que dissemos
		; sobre LEA..
		02: 8D BB 70 01 00+ lea edi, [ebx+170h]
		; EBX provavelmente é outra struct do mesmo tipo
		03: A5 movsd
		04: A5 movsd
		05: A5 movsd
		06: 66 A5 movsw
		07: A4 movsb


Depois das linhas 1–2, você sabe que EAX e EBX provavelmente são do mesmo tipo porque estão sendo usados como origem / destino e os
offsets são iguais. Este trecho de código simplesmente copia 15 bytes de um campo de uma struct p/ outra. Notamos que o código também
poderia ser escrito usando a instrução **MOVSB** com um prefixo **REP** e o **ECX**(counter) definido como 15; Entretanto isso seria
ineficiente pois resultaria em 15 leituras em vez de apanas 5.

Outra classe de instrução que movimenta dados com origem/destino implícitos inclui as instruções : **SCAS** e **STOS** . Semelhante aos _MOVS_, essas instruções podem operar em granulalidade de 1,2 ou 4 bytes.

**SCAS** compara implicitamente : __AL / AX / EAX__ com dados que começam no endereço de memória de EDI. EDI é decrementado/incrementado automaticamente dependendo da **DF** flag. Devido à sua semântica, o **SCAS** é comumente usado junto com o prefixo REP para encontrar um byte, word ou dword em um buffer. Por exemplo, a função C strlen () pode ser implementada da seguinte forma:

*Assembly - código 0x07*

		01: 30 C0 xor al, al
		; setando AL p/ 0 (NUL byte).Veremos frequentemente a instrução : XOR reg, reg
		; pattern in code para zerar o valor do registrador.
		02: 89 FB mov ebx, edi
		; save the original pointer to the string
		03: F2 AE repne scasb
		; avance repetidamente um byte de cada vez, desde que AL não corresponda ao
		; byte em EDI, quando esta instrução terminar significa que alcançamos o byte NUL no buffer de string.
		04: 29 DF sub edi, ebx
		; edi agora é onde está o NUL byte location. Subtraia isso do ponteiro original
		; para o tamanho



**STOS** é o mesmo que **SCAS**, exceto que grava o valor de __AL / AX / EAX__  em EDI. Isso é constantemente usado para inicializar um buffer com um valor constante(como memset()). Aqui está um exemplo :

*Assembly - código 0x08*

		01: 33 C0 xor eax, eax ; set EAX to 0
		02: 6A 09 push 9 ; push 9 on the stack
		03: 59 pop ecx ; pop it back in ECX. Now ECX = 9.
		04: 8B FE mov edi, esi ; set the destination address
		05: F3 AB rep stosd; write 36 bytes of zero to the destination buffer (STOSD repeated 9 times)
						   ; this is equivalent lent to memset(edi, 0, 36)


Observação : **LODS** é outra instrução da mesma família. Ela lê um valor de 1, 2 ou 4 bytes do ESI e o armazena em AL, AX ou EAX.



## Operadores Aritiméticos


Operações aritméticas fundamentais, como adição, subtração, multiplicação e divisão, são suportadas nativamente pelo conjunto de
instruções.As operações bit a bit, como AND, OR, XOR, NOT e deslocamento(shifts) para a esquerda e para a direita também têm instruções
correspondentes nativas. Com exceção da multiplicação e divisão, as instruções restantes são diretas em termos de uso. Essas operações
são explicadas com os seguintes Exemplos:


		01: 83 C4 14 add esp, 14h 		; esp = esp + 0x14
		02: 2B C8 sub ecx, eax 			; ecx = ecx - eax
		03: 83 EC 0C sub esp, 0Ch 		; esp = esp - 0xC
		04: 41 inc ecx 					; ecx = ecx + 1
		05: 4F dec edi 					; edi = edi - 1
		06: 83 C8 FF or eax, 0FFFFFFFFh ; eax = eax | 0xFFFFFFFF
		07: 83 E1 07 and ecx, 7 		; ecx = ecx & 7
		08: 33 C0 xor eax, eax 			; eax = eax ^ eax
		09: F7 D7 not edi 				; edi = ~edi
		10: C0 E1 04 shl cl, 4 			; cl = cl << 4
		11: D1 E9 shr ecx, 1 			; ecx = ecx >> 1
		12: C0 C0 03 rol al, 3 			; rotate AL left 3 positions
		13: D0 C8 ror al, 1 			; rotate AL right 1 position


 
As instruções de deslocamento para a esquerda e para a direita (linhas 11-12) merecem alguma explicação, pois são frequentemente 
observadas no código da vida real. Essas instruções são normalmente usadas para otimizar as operações de multiplicação e divisão onde
o multiplicando e o divisor são uma potência de dois. Este tipo de otimização às vezes é conhecido como redução de resistência porque
substitui uma operação computacionalmente cara por uma mais barata. Por exemplo, a divisão inteira é uma operação relativamente lenta,
mas quando o divisor é uma potência de dois, ele pode ser reduzido a bits deslocados para a direita; **100/2 é igual a 100 >> 1**. Da 
mesma forma, a multiplicação por uma potência de dois pode ser reduzido a bits deslocados para a esquerda; **100 * 2 é igual a 100 << 1**.

A multiplicação sem sinal e com sinal é feita através das instruções MUL e IMUL, respectivamente. A instrução MUL tem a seguinte forma
geral: MUL reg/memória. Ou seja, ele só pode operar em valores de registrador ou memória.O registrador é multiplicado por AL, AX ou EAX
e o resultado é armazenado em AX, DX:AX ou EDX:EAX, dependendo da largura do operando. Por exemplo:


		01: F7 E1 mul ecx 					; EDX:EAX = EAX * ECX
		02: F7 66 04 mul dword ptr [esi+4] 	; EDX:EAX = EAX * dword_at(ESI+4)
		03: F6 E1 mul cl 					; AX = AL * CL
		04: 66 F7 E2 mul dx 				; DX:AX = AX * DX

##### Considere alguns outros exemplos concretos:


		01: B8 03 00 00 00 mov eax,3 		 ; set EAX=3
		02: B9 22 22 22 22 mov ecx,22222222h ; set ECX=0x22222222
		03: F7 E1 mul ecx 					 ; EDX:EAX = 3 * 0x22222222 =
	 										 ; 0x66666666
	 									     ; hence, EDX=0, EAX=0x66666666

		04: B8 03 00 00 00 mov eax,3 		 ; set EAX=3
		05: B9 00 00 00 80 mov ecx,80000000h ; set ECX=0x80000000
		06: F7 E1 mul ecx 					 ; EDX:EAX = 3 * 0x80000000 =
		 									 ; 0x180000000
		 									 ; hence, EDX=1, EAX=0x80000000



A razão pela qual o resultado é armazenado em EDX:EAX para multiplicação de 32 bits é porque o resultado pode não caber em um
registrador de 32 bits (como demonstrado nas linhas 4–6).
IMUL tem três formas:


- **■ IMUL reg/mem — Same as MUL**
- **■ IMUL reg1, reg2/mem — reg1 = reg1 * reg2/mem**
- **■ IMUL reg1, reg2/mem, imm — reg1 = reg2 * imm**


Alguns disassemblers encurtam os parâmetros. Por exemplo :

		01: F7 E9 imul ecx 							; EDX:EAX = EAX * ECX
		02: 69 F6 A0 01 00+ imul esi, 1A0h  		; ESI = ESI * 0x1A0
		03: 0F AF CE imul ecx, esi 					; ECX = ECX * ESI


A divisão Unsigned e com sinal é feita por meio das instruções DIV e IDIV, respectivamente. Eles aceitam apenas um parâmetro (divisor)
e têm a seguinte forma: **DIV / IDIV reg / mem**. Dependendo do tamanho do divisor, o _DIV_ usará **AX, DX: AX ou EDX:EAX** como
dividendo e o par quociente / resto resultante é armazenado em AL / AH, AX / DX ou EAX / EDX. Por exemplo:


		01: F7 F1 div ecx 					 ; EDX:EAX / ECX, quotient in EAX,
		02: F6 F1 div cl 					 ; AX / CL, quotient in AL, remainder in AH
		03: F7 76 24 div dword ptr [esi+24h] ; see line 1
		04: B1 02 mov cl,2 					 ; set CL = 2
		05: B8 0A 00 00 00 mov eax,0Ah 		 ; set EAX = 0xA
		06: F6 F1 div cl 					 ; AX/CL = A/2 = 5 in AL (quotient),
		 									 ; AH = 0 (remainder)
		07: B1 02 mov cl,2 					 ; set CL = 2
		08: B8 09 00 00 00 mov eax,09h 		 ; set EAX = 0x9
		09: F6 F1 div cl 					 ; AX/CL = 9/2 = 4 in AL (quotient),
		 									 ; AH = 1 (remainder)



## Stack Operations and Function Invocation



A Stack(pilha) é uma estrutura de dados básica em linguagens de programação e sistemas operacionais. Por exemplo, variáveis locais em C
são armazenadas no function'stack space. Quando o sistema operacional faz a transição de ring 3 para ring 0, ele salva as informações
de estado na stack. Conceitualmente, uma Stack é uma estrutura de dados last-in first-out( ultimo que entra é o primeiro que sai) e
que suporta duas operações: __push e pop__. Empurrar(push) significa colocar algo no topo da pilha; pop significa remover um item do
topo da pilha. Falando concretamente, em x86, uma pilha é uma região de memória contígua apontada por ESP e ela cresce para baixo. As
operações _push / pop_ são feitas por meio das instruções **PUSH / POP** e modificam o ESP implicitamente. A instrução PUSH diminui
ESP e então grava os dados no local apontado por ESP; O POP lê os dados e incrementa o ESP. O valor padrão de incremento / decremento
automático é 4, mas pode ser alterado para 1 ou 2 com uma substituição de prefixo. Na prática, o valor é quase sempre 4 porque o SO
exige que a pilha seja alinhada com DWORDS. Suponha que ESP inicialmente aponte para 0xb20000 e você tenha o seguinte código:



		; initial ESP = 0xb20000
		01: B8 AA AA AA AA mov eax,0AAAAAAAAh
		02: BB BB BB BB BB mov ebx,0BBBBBBBBh
		03: B9 CC CC CC CC mov ecx,0CCCCCCCCh
		04: BA DD DD DD DD mov edx,0DDDDDDDDh
		05: 50 push eax
		; address 0xb1fffc will contain the value 0xAAAAAAAA and ESP
		; will be 0xb1fffc (=0xb20000-4)
		06: 53 push ebx
		; address 0xb1fff8 will contain the value 0xBBBBBBBB and ESP
		; will be 0xb1fff8 (=0xb1fffc-4)
		07: 5E pop esi	
		; ESI will contain the value 0xBBBBBBBB and ESP will be 0xb1fffc
		; (=0xb1fff8+4)
		08: 5F pop edi
		; EDI will contain the value 0xAAAAAAAA and ESP will be 0xb20000
		; (=0xb1fffc+4)


A Figura 1-3 ilustra o layout da Stack.


![stack](https://i.imgur.com/zurwkEh.png)


O **ESP** também pode ser modificado diretamente por outras instruções,como ADD e SUB. Apesar das linguagens de alto nível terem o
conceito de funções que podem ser chamadas e retornadas, o processador não fornece tal abstração. No nível mais baixo, o processador 
opera apenas em objetos concretos, como registradores ou dados vindos da memória. Como as funções são traduzidas no nível da máquina?
Eles são implementados por meio da estrutura de dados da pilha! Considerar a seguinte função :


**C**

		int
		__cdecl addme(short a, short b)
		{
		 return a+b;
		}



**Assembly**

		01: 004113A0 55 push ebp
		02: 004113A1 8B EC mov ebp, esp
		03: ...
		04: 004113BE 0F BF 45 08 movsx eax, word ptr [ebp+8]
		05: 004113C2 0F BF 4D 0C movsx ecx, word ptr [ebp+0Ch]
		06: 004113C6 03 C1 add eax, ecx
		07: ...
		08: 004113CB 8B E5 mov esp, ebp
		09: 004113CD 5D pop ebp
		10: 004113CE C3 retn


__A função é chamada com o seguinte código :__


**C**


		sum = addme(x, y) ;



**Aseembly**


		01: 004129F3 50 push eax
		02: ...
		03: 004129F8 51 push ecx
		04: 004129F9 E8 F1 E7 FF FF call addme
		05: 004129FE 83 C4 08 add esp, 8



Antes de entrar em detalhes, primeiro considere as instruções _CALL / RET_ e as convenções de chamada. A instrução **CALL** realiza
duas operações:

  1. Ele coloca o endereço de retorno (endereço imediatamente após a instrução CALL) na pilha.
  2. Ele muda o EIP para o destino da chamada. Isso transfere efetivamente o controle para o destino da chamada e começa a execução lá.


A instrução **RET** simplesmente coloca o endereço armazenado no topo da pilha no EIP e transfere o controle para ele (literalmente como um “POP EIP”, mas essa sequência de instruções não existe no x86). Por exemplo, se você deseja iniciar a execução em 0x12345678, pode apenas fazer o seguinte:


		01: 68 78 56 34 12 push 0x12345678
		02: C3 ret


A __calling convention__ é um conjunto de regras que ditam como as chamadas de função funcionam no nível da máquina ( baixo nível ).
É definido pela Interface Binária do Aplicativo (ABI) para um sistema específico. Por exemplo, os parâmetros devem ser passados pela
pilha, em registradores ou em ambos? Os parâmetros devem ser passados da esquerda para a direita ou da direita para a esquerda? O
valor de retorno deve ser armazenado na pilha, em registradores ou em ambos?

Existem muitas convenções de chamada, mas as mais populares são : **CDECL, STDCALL, THISCALL e FASTCALL**. (O compilador também pode
gerar sua própria convenção de chamada personalizada, mas essas não serão discutidas aqui.) A Tabela 1-2 resume sua semântica.


![calling conv.](https://i.imgur.com/nrrTP2D.png)



Agora retornamos ao trecho de código para discutir como a função addme é chamada. Nas linhas 1 e 3, os dois parâmetros são colocados
na pilha; ECX e EAX são o primeiro e o segundo parâmetro, respectivamente. A linha 4 invoca a função addme com a instrução CALL. Isso
coloca imediatamente o endereço de retorno, 0x4129FE, na pilha e começa a execução em 0x4113A0. A Figura 1-4 ilustra o layout da pilha
após a linha 4 ser executada.


![smallstack](https://i.imgur.com/BKeaPy8.png)


- Após a execução da linha 4, estamos agora no corpo da função addme. 
- A linha 1 empurra EBP para a pilha. 
- A linha 2 define EBP para o ponteiro da pilha atual.

Essa sequência de duas instruções é normalmente conhecida como prólogo da função porque estabelece um novo frame de função.

- A linha 4 lê o valor no endereço EBP + 8, que é o primeiro parâmetro na pilha; 
- A linha 5 lê o segundo parâmetro.

Observe que os parâmetros são acessados ​​usando EBP como o registrador base. Quando usado neste contexto, EBP é conhecido como o ponteiro
do frame de base (consulte a linha 2) porque aponta para o frame de pilha da função atual e os parâmetros / locais podem ser
acessados ​​em relação a ele. O compilador também pode ser instruído a gerar código que não use EBP como o ponteiro do frame base por
meio de uma otimização chamada omissão do ponteiro do frame. Com essa otimização, o acesso às variáveis ​​e parâmetros locais é feito em
relação ao ESP, e o EBP pode ser usado como um registrador geral como EAX, EBX, ECX e assim por diante. A linha 6 adiciona os números e
salva o resultado em EAX. A linha 8 define o ponteiro da pilha para o ponteiro do frame base.

- A linha 9 ativa o EBP salvo da linha 1 para o EBP.

Essa sequência de duas instruções é comumente referida como o epílogo da função porque está no final da função e restaura o frame de
função anterior. Neste ponto, o topo da pilha contém o endereço de retorno salvo pela instrução CALL em 0x4129F9.

- A linha 10 realiza um RET, que abre a stack e retoma a execução em 0x4129FE.
- A linha 5 no fragmento reduz a pilha em 8 porque o chamador deve limpar a pilha de acordo com a convenção de chamada de CDECL.

Se a função addme tivesse variáveis ​​locais, o código precisaria aumentar a pilha subtraindo ESP após a linha 2. Todas as variáveis ​​locais seriam acessíveis por meio de um deslocamento negativo de EBP.



## Controle de Fluxo


Esta seção descreve como o sistema implementa a execução condicional para construções de alto nível como if/else, switch/case e while/
for. Todos eles são implementados por meio das instruções CMP, TEST, JMP e Jcc e do registrador EFLAGS. A lista a seguir resume as
flags mais comuns em EFLAGS:


**■ ZF/Zero flag — É definido se o resultado da operação anterior for zero.**
**■ SF/Sign flag — Defina para a parte mais significativa do resultado.**
**■ CF/Carry flag — Definido quando o resultado requer um transporte(cary). Isso se aplica a valores sem sinal(unsigned)..**
**■ OF/Overflow flag — Definido se o resultado ultrapassar o tamanho máximo. Aplica-se a valores com sinal(signed)**


As instruções aritméticas atualizam esses sinalizadores com base no resultado. Por exemplo, a instrução SUB EAX, EAX faria com que ZF
fosse definido. As instruções Jcc, onde “cc” é um código condicional, altera o fluxo de controle dependendo desses sinalizadores. Pode
haver até 16 códigos condicionais, mas os mais comuns são descritos na Tabela 1-3.


![Eflags](https://i.imgur.com/Js4vcwb.png)


Como a linguagem assembly não tem um sistema de tipo definido, uma das poucas maneiras de reconhecer tipos com / sem sinal é por meio
desses códigos condicionais. A instrução CMP compara dois operandos e define o código condicional apropriado em EFLAGS; ele compara
dois números subtraindo um do outro sem atualizar o resultado. A instrução TEST faz a mesma coisa, exceto que executa um AND lógico
entre os dois operandos.



#### If-Else

As construções If-else são bastante simples de reconhecer porque envolvem uma comparação / teste seguida por um Jcc. Por exemplo:

**Assembly**


		01: mov esi, [ebp+8]
		02: mov edx, [esi]
		03: test edx, edx
		04: jz short loc_4E31F9
		05: mov ecx, offset _FsRtlFastMutexLookasideList
		06: call _ExFreeToNPagedLookasideList@8
		07: and dword ptr [esi], 0
		08: lea eax, [esi+4]
		09: push eax
		10: call _FsRtlUninitializeBaseMcb@4
		11: loc_4E31F9
		12: pop esi
		13: pop ebp
		14: retn 4
		15: _FsRtlUninitializeLargeMcb@4 endp


**Pseudo C**

		if (*esi == 0) {
		 return;
		}
		ExFreeToNPagedLookasideList(...);
		*esi = 0;
		...
		return;
		OR
		if (*esi != 0) {
		 ...
		 ExFreeToNPagedLookasideList(...);
		 *esi = 0;
		 ...
		}
		return


- A linha 2 lê um valor no local ESI e o armazena em EDX. 
- A linha 3 ANDs EDX consigo mesma e define os sinalizadores apropriados em EFLAGS. Observe que esse padrão é comumente usado para 
saber se um registrador é zero. 
- A linha 4 salta para loc_4E31F9 (linha 12) se ZF = 1. Se ZF = 0, então ele executa 
- A linha 5 e continua até que a função retorne. Observe que existem duas traduções C ligeiramente diferentes, mas logicamente
equivalentes para este trecho.


#### Switch-Case

Um bloco switch-case é uma sequência de instruções if / else. Por exemplo:

**Switch-Case**

		switch(ch) {
		 case 'c':
		 handle_C();
		 break;
		 case 'h':
		 handle_H();
		 break;
		 default:
		 break;
		}
		domore();
		


**If-Else**


		if (ch == 'c') {
		 handle_C();
		} else
		if (ch == 'h') {
		 handle_H();
		}
		domore();
		...



Portanto, a tradução do código de máquina será uma série if / else. O seguinte exemplo simples ilustra a ideia:


**Assembly**

		01: push ebp
		02: mov ebp, esp
		03: mov eax, [ebp+8]
		04: sub eax, 41h
		05: jz short loc_caseA
		06: dec eax
		07: jz short loc_caseB
		08: dec eax
		09: jz short loc_caseC
		10: mov al, 5Ah
		11: movzx eax, al
		12: pop ebp
		13: retn
		14: loc_caseC:
		15: mov al, 43h
		16: movzx eax, al
		17: pop ebp
		18: retn
		19: loc_caseB:
		20: mov al, 42h
		21: movzx eax, al
		22: pop ebp
		23: retn
		24: loc_caseA:
		25: mov al, 41h
		26: movzx eax, al
		27: pop ebp
		28: retn



**C**


		unsigned char switchme(int a)
			{
			 unsigned char res;
			 switch(a) {
			 case 0x41:
			 res = 'A';
			 break;
			 case 0x42:
			 res = 'B';
			 break;
			 case 0x43:
			 res = 'C';
			 break;
			 default:
			 res = 'Z';
			 break;
			 }
			 return res;
			}


Aqui, o compilador sabe que existem apenas cinco casos e o valor do caso é consecutivo; portanto, ele pode construir a tabela de salto
e indexar nela diretamente (linha 3). Sem a tabela de salto, haveria 10 instruções adicionais para testar cada caso e desviar para o
manipulador. (Existem outras formas de otimizações de switch / case, mas não as cobriremos aqui.)



#### Loops


No nível da máquina, os loops são implementados usando uma combinação de instruções Jcc e JMP. Em outras palavras, eles são
implementados usando as construções if / else e goto. A melhor maneira de entender isso é reescrever um loop usando apenas if / else e
goto. Considere o seguinte exemplo:


**Using for**

		for (int i=0; i<10; i++) {
		 printf("%d\n", i);
		}
		printf("done!\n");


**Using if/else and goto**


		int i = 0;
		loop_start:
		 if (i < 10) {
		 printf("%d\n", i);
		 i++;
		 goto loop_start;
		 }
		printf("done!n");



Quando compiladas, as duas versões são idênticas no nível do código de máquina:


		01: 00401002 mov edi, ds:__imp__printf
		02: 00401008 xor esi, esi
		03: 0040100A lea ebx, [ebx+0]
		04: 00401010 loc_401010:
		05: 00401010 push esi
		06: 00401011 push offset Format ; "%d\n"
		07: 00401016 call edi ; __imp__printf
		08: 00401018 inc esi
		09: 00401019 add esp, 8
		10: 0040101C cmp esi, 0Ah
		11: 0040101F jl short loc_401010
		12: 00401021 push offset aDone ; "done!\n"
		13: 00401026 call edi ; __imp__printf
		14: 00401028 add esp, 4



- A linha 1 define EDI para a função printf. 
- A linha 2 define ESI como 0. 
- A linha 4 inicia o loop; no entanto, observe que ele não começa com uma comparação. Não há comparação aqui porque o compilador sabe 
que o contador foi inicializado em 0 (consulte a linha 2) e obviamente será menor que 10, portanto, a verificação será ignorada. As
- Linhas 5–7 chamam a função printf com os parâmetros corretos (especificador de formato e nosso número). 
- A linha 8 incrementa o número. 
- A linha 9 limpa a pilha porque printf usa a convenção de chamada CDECL. 
- A linha 10 verifica se o contador é menor que 0xA. Se for, ele volta para loc_401010. Se o contador não for menor que 0xA, ele
continua a execução. 
- Na linha 12 e termina com um printf.



Uma observação importante a fazer é que o disassembly nos permitiu inferir que o contador é um número inteiro assinado. A linha 11 usa
o código condicional (JL) “menor que”, então sabemos imediatamente que a comparação foi feita em inteiros com sinal. Lembre-se: Se
“acima / abaixo”, não tem sinal; se “menor que / maior que”, é assinado. A amostra L tem uma pequena função, sub_1000AE3B, com o
seguinte laço interessante.


**Assembly**

		01: sub_1000AE3B proc near
		02: push edi
		03: push esi
		04: call ds:lstrlenA
		05: mov edi, eax
		06: xor ecx, ecx
		07: xor edx, edx
		08: test edi, edi
		09: jle short loc_1000AE5B
		10: loc_1000AE4D:
		11: mov al, [edx+esi]
		12: mov [ecx+esi], al
		13: add edx, 3
		14: inc ecx
		15: cmp edx, edi
		16: jl short loc_1000AE4D
		17: loc_1000AE5B:
		18: mov byte ptr [ecx+esi], 0
		19: mov eax, esi
		20: pop edi
		21: retn
		22: sub_1000AE3B endp


**C**


		char *sub_1000AE3B (char *str)
		{
			 int len, i=0, j=0;
			 len = lstrlenA(str);
			 if (len <= 0) {
			 str[j] = 0;
			 return str;
			 }
			 while (j < len) {
			 str[i] = str[j];
			 j = j+3;
			 i = i+1;
			 }
			 str[i] = 0;
			 return str;
		}


A função sub_1000AE3B tem um parâmetro transmitido usando uma convenção de chamada personalizada (ESI contém o parâmetro). 
- A linha 2 salva EDI. 
- A linha 3 chama lstrlenA com o parâmetro; portanto, você sabe imediatamente que ESI é do tipo char *.* 
- A linha 5 salva o valor de retorno (comprimento da string) em EDI. 
- As linhas 6–7 eliminam ECX e EDX. 
- As linhas 8–9 verificam se o comprimento da string é menor ou igual a zero. Se for, o controle é transferido para a linha 18, que
define o valor em ECX + ESI para 0. Se for não, então a execução continua na linha 11, que é o início de um loop. Primeiro, ele lê o
caractere em ESI + EDX (linha 11) e, em seguida, o armazena em ESI + ECX (linha 12). 

Em seguida, ele incrementa o EDX e o ECX em três e um, respectivamente. As linhas 15–16 verificam se EDX é menor que o comprimento da
string; em caso afirmativo, a execução volta ao início do loop. Caso contrário, a execução continua na linha 18.

Pode parecer complicado no início, mas essa função usa uma string ofuscada cujo valor desofuscado está a cada três caracteres. Por
exemplo, a string __SX] OTYFKPTY ^ W \\ aAFKRW \\ E__ é, na verdade, **SOFTWARE**.


O objetivo desta função é prevenir scanners de string ingênuos e evitar a detecção. Como exercício, você deve descompilar esta função
para que pareça mais “natural” (ao contrário de nossa tradução literal).

Fora das construções Jcc normais, certos loops podem ser implementados usando a instrução LOOP. A instrução LOOP executa um bloco de
código até a hora ECX. Por exemplo:


**Assembly**

		01: 8B CA mov ecx, edx
		02: loc_CFB8F:
		03: AD lodsd
		04: F7 D0 not eax
		05: AB stosd
		06: E2 FA loop loc_CFB8F

**Rough C**

		while (ecx != 0) {
		 eax = *edi;
		 edi++;
		 *esi = ~eax;
		 esi++;
		 ecx--;
		}


A linha 1 lê o contador do EDX. A linha 3 é o início do loop; ele lê uma palavra dupla no endereço de memória EDI e salva em EAX;
também incrementa o EDI em 4. A linha 4 executa o operador NOT no valor que acabou de ler. A linha 5 grava o valor modificado no
endereço de memória ESI e incrementa o ESI em 4. A linha 6 verifica se ECX é 0; caso contrário, a execução continua no início do loop.



## Mecanismo do Sistema



As seções anteriores explicam os mecanismos e instruções disponíveis para código em execução em todos os níveis de privilégio. Para
obter uma melhor apreciação da arquitetura, esta seção discute dois mecanismos fundamentais no nível do sistema: tradução de endereço
virtual e tratamento de exceções / interrupções. Você pode pular esta seção na primeira leitura.


### Address Translation  ( Tradução de Endereços )


A memória física em um sistema de computador é dividida em unidades de 4 KB chamadas de páginas. ( Uma página pode ter mais de 4 KB,
mas não discutiremos os outros tamanhos aqui.) Os endereços de memória são divididos em duas categorias: virtual e física. Os
endereços virtuais são aqueles usados por instruções executadas no processador quando a paginação está habilitada. Por exemplo:


		01: A1 78 56 34 12 mov eax, [0x12345678]	; read memory at the virtual address 0x12345678
		01: 89 08 mov [eax], ecx 					; write ECX at the virtual address EAX



Os endereços físicos são as localizações reais da memória usadas pelo processador ao acessar a memória. O  __Processor's Memory
Management Unit (MMU)__ do processador traduz de forma transparente cada endereço virtual em um endereço físico antes de acessá-lo.
Embora um endereço virtual possa parecer apenas mais um número para o usuário, há uma estrutura nele quando visualizado pela MMU.
Em sistemas x86 com suporte a __Physical Address Extension (PAE)__, um endereço de memória virtual pode ser dividido em índices em três tabelas e offsets : 

- tabela de ponteiro de diretório de página (PDPT), 
- diretório de página (PD), 
- tabela de página (PT) 
- tabela de página entrada (PTE). 	

Um PDPT é uma matriz de quatro elementos de 8 bytes, cada um apontando para um PD. Um PD é uma matriz de 512 elementos de 8 bytes,
cada um apontando para um PT. Um PT é uma matriz de 512 elementos de 8 bytes, cada um contendo um PTE. Por exemplo, o endereço
virtual 0xBF80EE6B pode ser entendido conforme mostrado na Figura 1-5.

![Imgur](https://i.imgur.com/TBGtnjI.png)


Os elementos de 8 bytes nessas tabelas contêm dados sobre as tabelas, permissão de memória e outras características de memória. Por
exemplo, existem bits que determinam se a página é somente leitura ou leitura/escrita, executável ou não executável, acessível ao
usuário ou não, e assim por diante.

O processo de tradução de endereços gira em torno dessas três tabelas e do registrador **CR3**. **CR3** contém o endereço básico
físico do PDPT. O restante desta seção percorre a tradução do endereço virtual 0xBF80EE6B em um sistema real (consulte a Figura 1-5):


		kd> r @cr3 			; CR3 is the physical address for the base of a PDPT cr3=085c01e0
		kd> !dq @cr3+2*8 L1 ; read the PDPT entry at index 2 # 85c01f0 00000000`0d66e001



De acordo com a documentação, os 12 bits inferiores de uma entrada PDPT são fl ags / bits reservados e os restantes são usados como o endereço físico da base PD. O bit 63 é o fl ag do NX no PAE, portanto, você também precisará limpar isso. Neste exemplo específico, não o limpamos porque já é 0. (Estamos examinando páginas de código que são executáveis.)


		; 0x00000000`0d66e001 = 00001101 01100110 11100000 00000001
		; after clearing the bottom 12 bits, we have
		; 0x0d66e000 = 00001101 01100110 11100000 00000000
		; This tells us that the PD base is at physical address 0x0d66e000
		kd> !dq 0d66e000+0x1fc*8 L1 ; read the PD entry at index 0x1FC
		# d66efe0 00000000`0964b063


###### Novamente, de acordo com a documentação, os 12 bits inferiores de uma entrada PD são usados para flags / bits reservados, e os 
restantes são usados como base para o P




		; 0x0964b063 = 00001001 01100100 10110000 01100011
		; after clearing the bottom 12 bits, we get
		; 0x0964b000 = 00001001 01100100 10110000 00000000
		; This tells us that the PT base is at 0x0964b000
		kd> !dq 0964b000+e*8 L1 ; read the PT entry at index 0xE
		# 964b070 00000000`06694021


###### Novamente, os 12 bits inferiores podem ser apagados para chegar à base de uma entrada de página



		; 0x06694021 = 00000110 01101001 01000000 00100001
		; after clearing bottom 12 bits, we get
		; 0x06694000 = 00000110 01101001 01000000 00000000
		; This tells us that the page entry base is at 0x06694000
		kd> !db 06694000+e6b L8 ; read 8 bytes from the page entry at offset
		0xE6B
		# 6694e6b 8b ff 55 8b ec 83 ec 0c ..U.....[).t.... ; our data at that
		 ; physical page
		kd> db bf80ee6b L8 ; read 8 bytes from the virtual address
		bf80ee6b 8b ff 55 8b ec 83 ec ..U.....[).t.... ; same data!


Após todo o processo, é determinado que o endereço virtual 0xBF80EE6B se traduz no endereço físico 0x6694E6B.
Os sistemas operacionais modernos implementam separação de espaço de endereço de processo usando esse mecanismo. Cada processo está associado a um CR3 diferente, resultando na tradução de endereço virtual específico do processo. É a magia por trás da ilusão de cada processo de que ele tem seu próprio espaço de endereço. Esperamos que você aprecie mais o processador da próxima vez que seu programa acessar a memória!




### Interrupts and Exceptions (Interrupções e Exceções)


Esta seção discute brevemente as interrupções e exceções, pois os detalhes completos da implementação podem ser encontrados no
Capítulo 3, “O Kernel do Windows”. Em sistemas de computação contemporâneos, o processador é normalmente conectado a dispositivos
periféricos por meio de um barramento de dados, como PCI Express, FireWire ou USB.

Quando um dispositivo requer a atenção do processador, ele causa uma interrupção que força o processador a pausar o que quer que esteja fazendo e lidar com a solicitação do dispositivo. Como o processador sabe como lidar com a solicitação? No nível mais alto, pode-se pensar em uma interrupção como sendo associada a um número que é então usado para indexar em uma matriz de ponteiros de função. Quando o processador recebe a interrupção, ele executa a função no índice associado à interrupção e retoma a execução de onde estava antes da interrupção ocorrer. Elas são chamadas de interrupções de hardware porque são geradas por dispositivos de hardware. Elas são assíncronas por natureza.

Quando o processador está executando uma instrução, ele pode encontrar exceções. Por exemplo, uma instrução pode gerar um erro de divisão por zero, fazer referência a um endereço inválido ou disparar uma transição de nível de privilégio. Para o propósito desta discussão, as exceções podem ser classificadas em duas categorias: falhas e armadilhas. Uma falha é uma exceção corrigível. Por exemplo, quando o processador executa um
instrução que faz referência a um endereço de memória válido, mas os dados não estão presentes na memória principal (foram paginados), uma exceção de falha de página é gerada. O processador lida com isso salvando o estado de execução atual, chamando o manipulador de falha de página para corrigir essa exceção (paginando os dados) e reexecutando a mesma instrução (que não deve mais causar uma falha de página). Uma armadilha é um
exceção causada pela execução de tipos especiais de instruções. Por exemplo, a instrução SYSENTER faz com que o processador comece a executar o manipulador de chamadas de sistema genérico; após a conclusão do manipulador, a execução é retomada na instrução imediatamente após SYSENTER. Portanto, a principal diferença entre uma falha e uma armadilha é onde a execução é reiniciada. Os sistemas operacionais comumente implementam
chamadas de sistema por meio do mecanismo de interrupção e exceção.


### Walk-Through ( passo a passo )


Concluímos o capítulo com um passo a passo de uma função com menos de 100 instruções. É a rotina DllMain do Sample J. Este exercício tem dois objetivos. Primeiro, ele aplica quase todos os conceitos cobertos no capítulo (exceto para caixa de comando). Em segundo lugar, ensina um requisito importante na prática da engenharia reversa: a leitura de manuais técnicos e documentação online. Aqui está a função:




		01: ; BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason,
		 ; LPVOID lpvReserved)
		02: _DllMain@12 proc near
		03: 55 push ebp
		04: 8B EC mov ebp, esp
		05: 81 EC 30 01 00+ sub esp, 130h
		06: 57 push edi
		07: 0F 01 4D F8 sidt fword ptr [ebp-8]
		08: 8B 45 FA mov eax, [ebp-6]
		09: 3D 00 F4 03 80 cmp eax, 8003F400h
		10: 76 10 jbe short loc_10001C88 (line 18)
		11: 3D 00 74 04 80 cmp eax, 80047400h
		12: 73 09 jnb short loc_10001C88 (line 18)
		13: 33 C0 xor eax, eax
		14: 5F pop edi
		15: 8B E5 mov esp, ebp
		16: 5D pop ebp
		17: C2 0C 00 retn 0Ch
		18: loc_10001C88:
		19: 33 C0 xor eax, eax
		20: B9 49 00 00 00 mov ecx, 49h
		21: 8D BD D4 FE FF+ lea edi, [ebp-12Ch]
		22: C7 85 D0 FE FF+ mov dword ptr [ebp-130h], 0
		23: 50 push eax
		24: 6A 02 push 2
		25: F3 AB rep stosd
		26: E8 2D 2F 00 00 call CreateToolhelp32Snapshot
		27: 8B F8 mov edi, eax
		28: 83 FF FF cmp edi, 0FFFFFFFFh
		29: 75 09 jnz short loc_10001CB9 (line 35)
		30: 33 C0 xor eax, eax
		31: 5F pop edi
		32: 8B E5 mov esp, ebp
		33: 5D pop ebp
		34: C2 0C 00 retn 0Ch
		35: loc_10001CB9:
		36: 8D 85 D0 FE FF+ lea eax, [ebp-130h]
		37: 56 push esi
		38: 50 push eax
		39: 57 push edi
		40: C7 85 D0 FE FF+ mov dword ptr [ebp-130h], 128h
		41: E8 FF 2E 00 00 call Process32First
		42: 85 C0 test eax, eax
		43: 74 4F jz short loc_10001D24 (line 70)
		44: 8B 35 C0 50 00+ mov esi, ds:_stricmp
		45: 8D 8D F4 FE FF+ lea ecx, [ebp-10Ch]
		46: 68 50 7C 00 10 push 10007C50h
		47: 51 push ecx
		48: FF D6 call esi ; _stricmp
		49: 83 C4 08 add esp, 8
		50: 85 C0 test eax, eax
		51: 74 26 jz short loc_10001D16 (line 66)
		52: loc_10001CF0:
		53: 8D 95 D0 FE FF+ lea edx, [ebp-130h]
		54: 52 push edx
		55: 57 push edi
		56: E8 CD 2E 00 00 call Process32Next
		57: 85 C0 test eax, eax
		58: 74 23 jz short loc_10001D24 (line 70)
		59: 8D 85 F4 FE FF+ lea eax, [ebp-10Ch]
		60: 68 50 7C 00 10 push 10007C50h
		61: 50 push eax
		62: FF D6 call esi ; _stricmp
		63: 83 C4 08 add esp, 8
		64: 85 C0 test eax, eax
		65: 75 DA jnz short loc_10001CF0 (line 52)
		66: loc_10001D16:
		67: 8B 85 E8 FE FF+ mov eax, [ebp-118h]
		68: 8B 8D D8 FE FF+ mov ecx, [ebp-128h]
		69: EB 06 jmp short loc_10001D2A (line 73)
		70: loc_10001D24:
		71: 8B 45 0C mov eax, [ebp+0Ch]
		72: 8B 4D 0C mov ecx, [ebp+0Ch]
		73: loc_10001D2A:
		74: 3B C1 cmp eax, ecx
		75: 5E pop esi
		76: 75 09 jnz short loc_10001D38 (line 82)
		77: 33 C0 xor eax, eax
		78: 5F pop edi
		79: 8B E5 mov esp, ebp
		80: 5D pop ebp
		81: C2 0C 00 retn 0Ch
		82: loc_10001D38:
		83: 8B 45 0C mov eax, [ebp+0Ch]
		84: 48 dec eax
		85: 75 15 jnz short loc_10001D53 (line 93)
		86: 6A 00 push 0
		87: 6A 00 push 0
		88: 6A 00 push 0
		89: 68 D0 32 00 10 push 100032D0h
		90: 6A 00 push 0
		91: 6A 00 push 0
		92: FF 15 20 50 00+ call ds:CreateThread
		93: loc_10001D53:
		94: B8 01 00 00 00 mov eax, 1
		95: 5F pop edi
		96: 8B E5 mov esp, ebp
		97: 5D pop ebp
		98: C2 0C 00 retn 0Ch
		99: _DllMain@12 endp


As linhas 3-4 configuram o prólogo da função, que salva o ponteiro do quadro de base anterior e estabelece um novo. A linha 5 reserva 0x130 bytes de espaço de pilha. A linha 6 salva EDI. A linha 7 executa a instrução SIDT, que escreve o registro IDT de 6 bytes em uma região de memória especificada. A linha 8 lê uma palavra dupla em EBP-6 e a salva no EAX. As linhas 9–10 verificam se EAX está abaixo ou igual a 0x8003F400. Se for, a execução é transferida para a linha 18; caso contrário, ele continua executando na linha 11. As linhas 11-12 fazem uma verificação semelhante, exceto que a condição não é inferior a 0x80047400. Se for, a execução é transferida para a linha 18; caso contrário, ele continua executando na linha 13. A linha 13 limpa EAX. A linha 14 restaura o registro EDI salvo na linha 6. As linhas 15–16 restauram o quadro de base anterior e o ponteiro da pilha. A linha 17 adiciona bytes 0xC ao ponteiro da pilha e então retorna ao chamador. Antes de discutir a próxima área, observe algumas coisas sobre essas primeiras 17 linhas. A instrução SIDT (linha 7) escreve o conteúdo do registrador IDT em um local de memória de 6 bytes. O que é o registro IDT? O manual de referência da Intel / AMD afirma que IDT é uma matriz de 256 entradas de 8 bytes, cada uma contendo um ponteiro para um manipulador de interrupção, seletor de segmento e deslocamento. Quando ocorre uma interrupção ou exceção, o processador usa o número da interrupção como um índice no IDT e chama o manipulador especificado da entrada. O registro IDT é um registro de 6 bytes; os 4 bytes superiores contêm a base da matriz / tabela IDT e os 2 bytes inferiores armazenam o limite da tabela. Com isso em mente, agora você sabe que a linha 8 está realmente lendo o endereço de base IDT. As linhas 9 e 11 verificam se o endereço base está na faixa (0x8003F400, 0x80047400). O que há de especial nessas constantes aparentemente aleatórias? Se você pesquisar na Internet, notará que 0x8003F400 é um endereço base IDT no Windows XP em x86. Isso pode ser verificado no depurador do kernel.




		0: kd> vertarget
		Windows XP Kernel Version 2600 (Service Pack 3) MP (2 procs) Free x86 compatible
		Built by: 2600.xpsp.080413-2111
		…
		0: kd> r @idtr
		idtr=8003f400
		0: kd> ~1
		1: kd> r @idtr
		idtr=bab3c590


Por que o código verifica esse comportamento? Uma possível explicação é que o desenvolvedor presumiu que um endereço de base IDT
zaindo nessa faixa é considerado “inválido” ou pode ser o resultado de ser virtualizado. A função retorna automaticamente zero se o
IDTR for “inválido”. Você pode descompilar este código para C da seguinte maneira:


		typedef struct _IDTR {
		 DWORD base;
		 SHORT limit;
		} IDTR, *PIDTR;
		BOOL __stdcall DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
		{
		 IDTR idtr;
		 __sidt(&idtr);
		 if (idtr.base > 0x8003F400 && idtr.base < 0x80047400h) { return FALSE; }
		 //line 18
		 ...
		}

**NOTA** :  Se você ler o manual com atenção, notará que cada processador tem seu próprio IDT e, portanto, IDTR. Portanto, em um sistema com vários núcleos, o IDTR será diferente para cada núcleo. Claramente, 0x8003F400 é válido apenas para o núcleo 0 no Windows XP. Se a instrução fosse programada para ser executada em outro núcleo, o IDTR seria 0xBAB3C590. Em versões posteriores do Windows, os endereços de base IDT mudam entre as reinicializações; portanto, a prática de codificar endereços de base não funcionará.


Se a base IDT parecer válida, o código continua a execução na linha 18. As linhas 19–20 apagam EAX e definem ECX como 0x49. A linha 21 usa conjuntos de EDI para qualquer EBP-0x12C; como EBP é o ponteiro do quadro base, EBP-0x12C é o endereço de uma variável local. A linha 22 escreve zero no local apontado por EBP-0x130. As linhas 23–24 empurram EAX e 2 na pilha. A linha 25 zera um buffer de 0x124 bytes a partir de EBP-0x12C. A linha 26 chama CreateToolhelp32Snapshot:


		HANDLE WINAPI CreateToolhelp32Snapshot(
		 _In_  DWORD dwFlags,
		 _In_  DWORD th32ProcessID
		);


Esta função da API Win32 leva dois parâmetros inteiros. Como regra geral, as funções da API do Win32 seguem a convenção de chamada STDCALL. Portanto, os parâmetros dwFlags e th32ProcessId são 0 x 2 (linha 24) e 0 x 0 (linha 23). Esta função enumera todos os processos no sistema e retorna um identificador para ser usado em Process32Next. As linhas 27–28 salvam o valor de retorno em EDI e verificam se é -1. Se for, o valor de retorno é definido como 0 e retorna (linhas 30–34); caso contrário, a execução continua na linha 35. A linha 36 define EAX para o endereço da variável local previamente inicializada em 0 na linha 22; a linha 40 o inicializa para 0x128. As linhas 37–39 colocam ESI, EAX e EDI na pilha. A linha 41 chama Process32First:


**Functions Prototype**:


		BOOL WINAPI Process32First(
		 _In_ HANDLE hSnapshot,
		 _Inout_ LPPROCESSENTRY32 lppe
		);  


**Relevant structure definition**


		typedef struct tagPROCESSENTRY32 {
		 DWORD dwSize;
		 DWORD cntUsage;
		 DWORD th32ProcessID;
		 ULONG_PTR th32DefaultHeapID;
		 DWORD th32ModuleID;
		 DWORD cntThreads;
		 DWORD th32ParentProcessID;
		 LONG pcPriClassBase;
		 DWORD dwFlags;
		 TCHAR szExeFile[MAX_PATH];
		} PROCESSENTRY32, *PPROCESSENTRY32;
		00000000 PROCESSENTRY32 struc ; (sizeof=0x128)
		00000000 dwSize dd ?
		00000004 cntUsage dd ?
		00000008 th32ProcessID dd ?
		0000000C th32DefaultHeapID dd ?
		00000010 th32ModuleID dd ?
		00000014 cntThreads dd ?
		00000018 th32ParentProcessID dd ?
		0000001C pcPriClassBase dd ?
		00000020 dwFlags dd ?
		00000024 szExeFile db 260 dup(?)
		00000128 PROCESSENTRY32 ends



Como essa API leva dois parâmetros, hSnapshot é EDI (linha 39, anteriormente o identificador retornado de CreateToolhelp32Snapshot na linha 27) e lppe é o endereço de uma variável local (EBP-0x130). Como o lppe aponta para uma estrutura PROCESSENTRY32, nós
saiba imediatamente que a variável local em EBP-0x130 é do mesmo tipo. Também faz sentido porque a documentação para Process32First afirma que antes de chamar a função, o campo dwSize deve ser definido com o tamanho de uma estrutura PROCESSENTRY32 (que é 0x128). Agora sabemos que as linhas 19-25 estavam simplesmente inicializando essa estrutura em 0. Além disso, podemos dizer que essa variável local começa em EBP-0x130 e termina em EBP-0x8.


A linha 42 testa o valor de retorno de Process32Next. Se for zero, a execução começa na linha 70; caso contrário, continua na linha 43. A linha 44 salva o endereço da função stricmp no ESI. A linha 45 define ECX para o endereço de uma variável local (EBP-0x10C), que por acaso é um campo em PROCESSENTRY32 (consulte o parágrafo anterior). As linhas 46-48 empurram 0x10007C50 / ECX na pilha e chamam stricmp. Sabemos que stricmp recebe duas cadeias de caracteres como argumentos; portanto, ECX deve ser o campo szExeFile em PROCESSENTRY32 e 0x10007C50 é o endereço de uma string


		.data:10007C50 65 78 70 6C 6F+Str2 db 'explorer.exe',0


A linha 49 limpa a pilha porque stricmp usa a convenção de chamada **CDECL**. A linha 50 verifica o valor de retorno do stricmp. Se for zero, significando que a string correspondeu a "explorer.exe", a execução começa na linha 66; caso contrário, ele continua a execução na linha 52. Agora podemos descompilar as linhas 18-51 da seguinte maneira:




		HANDLE h;
		 PROCESSENTRY32 procentry;
		 h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		 if (h == INVALID_HANDLE_VALUE) { return FALSE; }

		 memset(&procentry, 0, sizeof(PROCESSENTRY32));
		 procentry.dwSize = sizeof(procentry); // 0x128
		 if (Process32Next(h, &procentry) == FALSE) {
		 // line 70
		 ...
		 }
		 if (stricmp(procentry.szExeFile, "explorer.exe") == 0) {
		 // line 66
		 ...
		 }
		 // line 52



As linhas 52–65 são quase idênticas ao bloco anterior, exceto que formam um loop com duas condições de saída. A primeira condição de saída é quando Process32Next retorna FALSE (linha 58) e a segunda é quando stricmp retorna zero. Podemos descompilar as linhas 52-65 da seguinte maneira:


		 while (Process32Next(h, &procentry) != FALSE) {
		 if (stricmp(procentry.szExeFile, "explorer".exe") == 0)
		 break;
		 


Depois que o loop termina, a execução continua na linha 66. As linhas 67–68 salvam o _PROCESSENTRY32'sth32ParentProcessID / th32ProcessID_ em EAX / ECX e continuam a execução em 37. Observe que a linha 66 também é um destino de salto na linha 43. Linhas 70–74 leia o parâmetro _fdwReason_ de DllMain (EBP + C) e verifique se ele é 0 (DLL_PROCESS_DETACH). Se for, o valor de retorno é definido como 0 e ele retorna; caso contrário, ele vai para a linha 82. As linhas 82-85 verificam se fdwReason é maior que 1 (ou seja, DLL_THREAD_ATTACH, DLL_THREAD_DETACH). Se for, o retorno o valor é definido como 1 e retorna; caso contrário, a execução continua na linha 86. As linhas 86 a 92 chamam **CreateThread** :


		HANDLE WINAPI CreateThread(
		 _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
		 _In_ SIZE_T dwStackSize,
		 _In_ LPTHREAD_START_ROUTINE lpStartAddress,
		 _In_opt_ LPVOID lpParameter,
		 _In_ DWORD dwCreationFlags,
		 _Out_opt_ LPDWORD lpThreadId
		);


com *lpStartAddress* como 0x100032D0. Este bloco pode ser descompilado da seguinte forma:



		if (fdwReason == DLL_PROCESS_DETACH) { return FALSE; }
		if (fdwReason == DLL_THREAD_ATTACH || fdwReason == DLL_THREAD_DETACH) {
		 return TRUE; }
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE) 0x100032D0, 0, 0, 0);
		return TRUE;



Tendo analisado a função, podemos deduzir que a intenção original do desenvolvedor era esta:

1. Detecte se a máquina alvo tem um IDT “lógico”.
2. Verifique se “explorer.exe” está sendo executado no sistema - ou seja, alguém conectado.
3. Crie um thread principal que infecte a máquina de destino



## x64


x64 é uma extensão do x86, portanto, a maioria das propriedades da arquitetura são as mesmas, com pequenas diferenças, como tamanho
dos registradores e algumas instruções não estão disponíveis (como PUSHAD). As seções a seguir discutem as diferenças relevantes.


### Register and Data Types


O conjunto de registros tem 18 GPRs de 64 bits e pode ser ilustrado conforme mostrado na Figura 1-6. Observe que os registros de 64 bits têm o prefixo “R”.


![RAX](https://i.imgur.com/pG6MOJp.png)


Embora o RBP ainda possa ser usado como o ponteiro do quadro base, raramente é usado para esse propósito no código gerado pelo compilador da vida real. A maioria dos compiladores x64 simplesmente trata o RBP como outro GPR e faz referência a variáveis locais relativas ao RSP.



### Data Movement

x64 oferece suporte a um conceito conhecido como __RIP-relative-addressing__, que permite que as instruções façam referência aos
dados em uma posição relativa ao RIP. Por exemplo :


		01: 0000000000000000 48 8B 05 00 00+ mov rax, qword ptr cs:loc_A
		02: ; originally written as "mov rax,
		[rip]"
		03: 0000000000000007 loc_A:
		04: 0000000000000007 48 31 C0 xor rax, rax
		05: 000000000000000A 90 nop


A linha 1 lê o endereço de loc_A (que é 0x7) e o salva em RAX. O endereçamento relativo ao RIP é usado principalmente para facilitar
o código independente da posição. A maioria das instruções aritméticas são automaticamente promovidas para 64 bits, embora os
operandos tenham apenas 32 bits. Por exemplo  :


		48 B8 88 77 66+ mov rax, 1122334455667788h
		31 C0 xor eax, eax ; will also clear the upper 32bits of RAX.
		 ; i.e., RAX=0 after this
		48 C7 C0 FF FF+ mov rax,0FFFFFFFFFFFFFFFFh
		FF C0 inc eax ; RAX=0 after this


### Canonical Address


No x64, os endereços virtuais têm 64 bits de largura, mas a maioria dos processadores não oferece suporte a um espaço de endereço virtual completo de 64 bits. Os processadores Intel / AMD atuais usam apenas 48 bits para o espaço de endereço. Todos os endereços de memória virtual devem estar no formato canônico. Um endereço virtual está na forma canônica se os bits 63 até o bit implementado mais significativo forem todos 1s ou 0s. Em termos práticos, significa que os bits 48-63 precisam corresponder ao bit 47. Por exemplo:



		0xfffff801`c9c11000 = 11111111 11111111 11111000 00000001 11001001 11000001
		 00010000 00000000 ; canonical
		0x000007f7`bdb67000 = 00000000 00000000 00000111 11110111 10111101 10110110
		 01110000 00000000 ; canonical
		0xffff0800`00000000 = 11111111 11111111 00001000 00000000 00000000 00000000
		 00000000 00000000 ; non-canonical
		0xffff8000`00000000 = 11111111 11111111 10000000 00000000 00000000 00000000
		 00000000 00000000 ; canonical
		0xfffff960`000989f0 = 11111111 11111111 11111001 01100000 00000000 00001001
		 10001001 11110000 ; canonical

Se o código tentar cancelar a referência de um endereço não canônico, o sistema causará uma exceção.



### Function Invocation


Lembre-se de que algumas convenções de chamada exigem que os parâmetros sejam passados na pilha no x86. No x64, a maioria das convenções de chamada passam parâmetros por meio de registradores. Por exemplo, no Windows x64, há apenas uma convenção de chamada e os primeiros quatro parâmetros são passados por RCX, RDX, R8 e R9; os restantes são colocados na pilha da direita para a esquerda. No Linux, os primeiros seis parâmetros são passados em RDI, RSI, RDX, RCX, R8 e R9.



**NOTA** : Para obter mais informações sobre x64 ABI no Windows, consulte a seção “Convenções de software x64” no MSDN
[Link](http://msdn.microsoft.com/en-us/library/7kcdt6fy.aspx).


