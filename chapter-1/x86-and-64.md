[Previous](../intro.md)
------------------------


# Capítulo 0x01 - x86 and x64



O x86 é a arquitetura little-endian baseada no processador Intel 8086. Para o propósito de nosso capítulo, x86 é a implementação de 32 bits da arquitetura Intel (IA-32), conforme definido no Intel Software Development Manual. De um modo geral,o IA-32 pode operar em dois modos: *real e protegido*. O modo real é o estado do processador quando é ligado pela primeira vez e suporta apenas um conjunto de instruções de 16 bits. O modo protegido é o estado do processador com suporte para memória virtual, paginação e outros recursos; é o estado em que os sistemas operacionais modernos são executados. A extensão de 64 bits da arquitetura é chamada de x64 ou x86-64. Este capítulo discute o **x86** operando em modo protegido.


O x86 oferece suporte ao conceito de separação de privilégios por meio duma abstração conhecida como Ring Level. O processador
suporta quatro ring levels, numerados de 0 a 3.(Os rings 1 e 2 não são comumente usados/conhecidos, portanto não são discutidos
aqui.) O __Ring 0__ é o nível que possui privilégio mais alto e pode modificar todas as configurações do sistema.O __Ring 3__ é o nível
de privilégios mais baixo e só pode ler/modificar um subconjunto das configurações do sistema. Portanto,sistemas operacionais
modernos geralmente implementam a separação de privilégios de user/kernel por ter aplicativos em user-mode executados
no Ring 3 e os de kernel-mode no Ring 0. O __ring revel__ é codificado no registrador **CS** e às vezes referido como o nível de
privilégio atual (CPL) na documentação oficial.

>Este capítulo discute a arquitetura x86 / IA-32 conforme definida no Intel 64 e IA-32 Architectures Software Developer’s
Manual, Volumes 1–3 (www.intel.com/content/www/us/en/processors/architectures-software-developermanuals.html)



## Registers Set and Data Types ( registradores e tipos de dados)



**GPRs - General Porpouse Registers** - registradores de uso geral

Ao operar em modo protegido, a arquitetura x86 fornece 8 registradores de uso geral (GPRs) de 32 bits. São eles: **EAX, EBX, ECX, EDX, EDI, ESI, EBP, and ESP**.
Alguns destes podem ser subdividios em registradores de 16 ou 8 bits. Exemplo : **EAX = 32 bits / AX = 16 bits AL ou AH = 8 bits**


![Imgur](https://i.imgur.com/IGbt60P.png)



_Alguns registradores e seus objetivos de origem_:


Registrador | Objetivo
------------| ----------------------------------------------------
ECX 	    | usado como contador nas implementações de loop
ESI         | usado como origem em operações com strings/memory
EDI         | usado como destino em operações com strings/memory
EBP         | Base frame pointer
ESP			| Stack pointer



Tipos de dados, e suas nomeclaturas mais cumuns :


- BYTE (8 bits)

		Ex : AL,BL,AH,BH

- WORD (16 bits)

		Ex : AX,BX,SI

- DWORD (32 bits)

		Ex : EAX,EBX,EDI

- QWORD (64 bits)

Embora o **x86** não tenha GPRs de 64 bits, ele pode combinar dois registradores, tipo( EDX:EAX ), e tratá-los como valores de 64 bits em alguns cenários; por exemplo usando a instrução [RDTSC](https://docs.microsoft.com/pt-br/cpp/intrinsics/
rdtsc?view=msvc-160) é possível gravar um valor de 64 bits em EDX:EAX


O Instruction Pointer(ponteiro p/ próxima instrução), tem um registrador padrão que guarda o endereço da próxima instrução :

		EIP = 32 bits

O registrador **EFLAGS** de 32 bits é usado para armazenar o status de operações aritméticas e outros estados de
execução. Quando a instrução anterior resultar em zero, **ZF**(Zero Flag, que é uma das flags mais importantes do EFLAGS)
será definida como 1. As flags de EFLAGS são usados principalmente para implementar ramificação condicionais.

		EFLAGS = 32 bits / cada bit = 1 FLAG

Além dos GPRs, EIP e EFLAGS, também existem registradores que controlam mecanismos importantes do sistema de low-level,como
virtual memory, interrupts e degugging. Por exemplo :

		CR0 = controla se a paginação está ativada ou desativada
		CR2 = contém o endereço linear que causou uma falha de página
		CR3 = é o endereço base de uma estrutura de dados de paginação
		CR4 = controla as configurações de virtualização de hardware.

		DR0 – DR7 =  são usados por Memory Breakpoints.
		Voltaremos a esses registradores mais tarde na seção “Mecanismo do sistema”.

_NOTE: Embora haja sete registradores de debugging, o sistema permite apenas quatro Memory BreakPoints (DR0-DR3).
Os registradores restantes são usados para validar status._


Existem também registradores específicos do modelo (MSRs). Como o nome indica, esses registradores podem variar entre os
diferentes processadores da Intel e AMD. Cada MSR é identificado por nome e um número de 32 bits, e é lido/escrito por meio
das instruções RDMSR/WRMSR. Eles são acessíveis apenas ao código rodando em ring 0 e normalmente são usados para armazenar
contadores especiais e implementar funcionalidade de low-level. Por exemplo, a instrução assembly *SYSENTER* transfere a
execução para o endereço armazenado no IA32_SYSENTER_EIP MSR (0x176), que geralmente é o manipulador das chamadas de sistema
(systemsCalls). MSRs são discutidos ao longo do livro à medida que aparecem.



## Instrutions Set ( conjunto de instruções )



O conjunto de instruções que o **x86** fornece, são bem flexivéis em termos de movimentação de dados entre registradores e memória.
Essa movimentação de dados, pode ser classificada em 5 tipos :

- Imediato p/ Registrador
- Registrador p/ Registrador
- Imediato p/ Memória
- Registrador p/ Memória e vice-versa
- Memória p/ Memória


Os primeiros quatro métodos são suportados por todas as arquiteturas modernas, mas o último é específico para x86.
Uma arquitetura RISC clássica como ARM só pode _LER/ESCREVER_ dados de/para memória com instruções de __load/store__. A instrução LDR and STR respectiva. Por exemplo uma operação simples como incrementar um valor na memória requer 3 instruções :

 1. Ler dados da memória para um registrador (LDR).
 2. Adicionar 1 ao registrador (ADD).
 3. Gravar o registrador na memória (STR)

No x86, tal operação exigiria apenas uma instrução (INC ou ADD) porque pode acessar a memória diretamente. A instrução MOVS
pode ler e escrever na memória ao mesmo tempo. Veja os exemplos :


**ARM**


	01: 1B 68 LDR R3, [R3] ; read the value at address R3
	02: 5A 1C ADDS R2, R3, #1 ; add 1 to it
	03: 1A 60 STR R2, [R3] ; write updated value back to address R3


**x86**


	01: FF 00 inc dword ptr [eax]
	; directly increment value at address EAX


Outra característica importante é que o **x86** usa o tamanho de instruções de comprimento variável: no o comprimento da instrução pode variar de 1 a 15 bytes. No **ARM**, as instruções têm 2 ou 4 bytes de comprimento.



Sintaxe
---------



Dependendo o assembler/disassembler, existem 2 variações de sintaxe da linguagem assembly x86 : __Intel ou AT&__ .


**Intel**


	mov ecx, AABBCCDDh
	mov ecx, [eax]
	mov ecx, eax


**AT&T**


	movl $0xAABBCCDD, %ecx
	movl (%eax), %ecx
	movl %eax, %ecx


É importante observar que essas são as mesmas instruções, mas escritas em sintaxes diferentes. Existem várias
diferenças entre a notação Intel e AT&T, mas as mais notáveis são as seguintes:


- A AT&T prefixa os registradores com *%* e imediatos com *$*. Intel não faz isso.

- A AT&T adiciona um prefixo à instrução para indicar a largura da operação. Por exemplo, MOVL (long), MOVB (byte),
etc.. A Intel não faz isso.

- A AT&T coloca o operando de origem antes do destino. A Intel inverte a ordem.


Disassemblers/Assemblers e outras ferramentas de engenharia reversa (IDA Pro, OllyDbg, MASM, etc.) no Windows geralmente usam a notação __Intel__, enquanto aqueles no UNIX frequentemente seguem a notação __AT&T__ (GCC). Na prática, a notação Intel é a forma dominante e é usada ao longo deste livro.



## Data Movement ( Movendo dados)



As instruções operam com valores que vem de registradores ou da main memory. A instrução mais comum
para mover dados é a instrução *MOV*.Exemplo de uso simples: mover um registrador ou um imediato para um
registrador. Por exemplo:

		01: BE 3F 00 0F 00 mov esi, 0F003Fh 	; set ESI = 0xF003
		02: 8B F1 		   mov esi, ecx     	; set ESI = ECX

O próximo uso comum é mover dados _DE/PARA_ memória. Semelhante a outras convenções da linguagem assembly o **x86** usa o Colchetes __[]__ para indicar acesso na memória. ( a única exceção é a instrução LEA, que usa os [ ] mas na verdade não faz referência a memória) O acesso a memória pode ser especificado de meneiras diferentes, portando começaremos com o caso mais simples :

*Assembly - código 0x00*

	01: C7 00 01 00 00+ 	mov dword ptr [eax], 1 	; mover 0x01 p/ offset de memória de EAX.
	02: 8B 08 				mov ecx, [eax] 		   	; mover p/ registrador ECX o valor contido no offset de memória de EAX
	03: 89 18 				mov [eax], ebx         	; mover p/ offset de memória de EAX o valor contido no registrador EBX
	04: 89 46 34 			mov [esi+34h], eax     	; mover p/ offset de (ESI+34) o valor do registrador EAX
	05: 8B 46 34 			mov eax, [esi+34h]     	; mover p/ registrador EAX o valor do offset de memória de (EAX+34)
	06: 8B 14 01 			mov edx, [ecx+eax]     	; mover p/ registrador EDX o valor do offset de memória de (ECX+EAX)


*Pseudo C*

	01: *eax = 1;
	02: ecx = *eax;
	03: *eax = ebx;
	04: *(esi+34) = eax;
	05: eax = *(esi+34);
	06: edx = *(ecx+eax);


Esses exemplos demonstram o acesso à memória por meio de um registrador base e um offset , onde o offset pode ser um registrador ou um operadando imediato. Essa forma é comumente usada para acessar itens das structs ou buffers de dados em um local calculado em tempo de execução.Por exemplo,suponha Wx''que *ECX* aponte para uma struct do tipo _KDPC_ com o seguinte layout :

	kd> dt nt!_KDPC
		 +0x000 Type : UChar
		 +0x001 Importance : UChar
		 +0x002 Number : Uint2B
		 +0x004 DpcListEntry : _LIST_ENTRY
		 +0x00c DeferredRoutine : Ptr32 void
		 +0x010 DeferredContext : Ptr32 Void
		 +0x014 SystemArgument1 : Ptr32 Void
		 +0x018 SystemArgument2 : Ptr32 Void
		 +0x01c DpcData : Ptr32 Void


E usado no seguinte contexto:

*Assembly - código 0x01*

	01: 8B 45 0C 		mov eax, [ebp+0Ch]
	02: 83 61 1C 00 	and dword ptr [ecx+1Ch], 0
	03: 89 41 0C 		mov [ecx+0Ch], eax
	04: 8B 45 10 		mov eax, [ebp+10h]
	05: C7 01 13 01 00+ mov dword ptr [ecx], 113h
	06: 89 41 10 		mov [ecx+10h], eax

*Pseudo C*

	KDPC *p = ...; 00?
	p->DpcData = NULL; 02!
	p->DeferredRoutine = ... ;03!
	*(int *)p = 0x113; 05?
	p->DeferredContext = ...; 06!


- A linha 1 lê um valor da memória e o armazena no registrador **EAX**. 
- O campo __DeferredRoutine__ é definido com este valor na linha 3. 
- A linha 2 limpa o campo __DpcData__ usando o operador **AND** com 0. 
- A linha 4 lê outro valor da memória e armazena em **EAX** 
- E por fim o campo __DeferredContext__ é definido com o último valor guardado em *EAX*.

- A linha 5 escreve uma DWORD com valor 0x113 na base da struct. Como ele escreve uma DWORD na base, se o primeiro
campo da struct tem apenas 1 BYTE de tamanho? Isso não definirá implicitamente os campos __Importance e Number__ ?
a RESPOSTA é sim! abaixo vemos o número 0x113 ser convertido pra binary pra ficar mais claro:


![Figure 1-2](https://i.imgur.com/1ULMDI4.png)

	
O campo "Type" é definido como 0x13 (bits em negrito), "Importance" é definido como 0x1 (bits itálicos) e Number é definido como 0x0
(o resto dos bits da DWORD). Ao escrever um valor, o código conseguiu inicializar três campos com uma única instrução! O código também
poderia estar escrito da seguinte forma:

*Assembly - código 0x02*

		01: 8B 45 0C mov eax, [ebp+0Ch]
		02: 83 61 1C 00 and dword ptr [ecx+1Ch], 0
		03: 89 41 0C mov [ecx+0Ch], eax
		04: 8B 45 10 mov eax, [ebp+10h]
		05: C6 01 13 mov byte ptr [ecx],13h
		06: C6 41 01 01 mov byte ptr [ecx+1],1
		07: 66 C7 41 02 00+ mov word ptr [ecx+2],0
		08: 89 41 10 mov [ecx+10h], eax

PS: _Agora a instrução que antes foi executada apenas na linha 5, está desmebrada em três linhas : 5,6,7_

O compilador decidiu juntar três instruções em uma, porque conhecia as constantes com antecedência e quis economizar espaço. A versão
de três instruções separadas ocupam 13 bytes (o byte extra na linha 7 não é mostrado), enquanto a versão de uma instrução ocupa 6 bytes
Outra observação interessante é que o acesso à memória pode ser feito em três níveis de granularidade: 

		BYTE, WORD, DWORD

O padrão sempre é 4 bytes (DWORD) , podendo ser alterada para 1 byte ou 2 bytes(WORD) usando um prefixo de substituição.
No exemplo, os bytes do prefixo de substituição são C6 e 66 (dos exemplos acima). Outros prefixos são discutidos à medida que aparecem.


A próxima forma de acesso à memória é comumente usada para acessar objetos do tipo array. Geralmente, o formato é o seguinte:

		[Base + Index *scale]

Isso é melhor compreendido por meio de exemplos e prática:


		01: 8B 34 B5 40 05+ mov esi, _KdLogBuffer[esi*4]

		; normalemente escrito assim:  mov esi, [_KdLogBuffer + esi * 4]
		; _KdLogBuffer é o Base address de uma array global e
		; ESI é o Index; sabemos que cada elemento da array
		; tem 4 bytes de comprimento (daí o fator de scale como = * x4)

		02: 89 04 F7 mov [edi+esi*8], eax
		; Aqui temos o EDI como o base address, ESI como o índice da array e o tamanho do scale é 0x08


Na prática, isso pode ser observado em um loop de código em uma array. Por exemplo:

*Assembly - código 0x03*

		01: loop_start:
		02: 8B 47 04 mov eax, [edi+4]
		03: 8B 04 98 mov eax, [eax+ebx*4]
		04: 85 C0 test eax, eax
		...
		05: 74 14 jz short loc_7F627F
		06: loc_7F627F:
		07: 43 inc ebx
		08: 3B 1F cmp ebx, [edi]
		09: 7C DD jl short loop_start


- Na linha 2 lê uma DWORD do offset EDI + 4 e então a usa como o Base address em um array 
- Na linha 3. Portanto, você sabe que o **EDI** é provavelmente uma struct que tem um array no offset "+4". 
- Na linha 7 incrementa o Index. 
- Na linha 8 compara o Index com o offset do Base Address da struct.

Com essas informações, esse pequeno loop pode ser decompilado da seguinte maneira:


		typedef struct _FOO
		{
		 DWORD size; // +0x00
		 DWORD array[...]; // +0x04
		} FOO, *PFOO;
		PFOO bar = ...;
		for (i = ...; i < bar->size; i++) {
		 if (bar->array[i] != 0) {
		 ...
		 }	
		}



As instruções **MOVSB ​​/ MOVSW / MOVSD** movem dados com granularidade de 1, 2 ou 4 bytes entre dois endereços de memória. E
respectivamente essas instruções usam implicitamente os registradores **EDI / ESI** como os endereços de DESTINO/ORIGEM.
Além disso, eles também atualizam automaticamente o endereço de DESTINO/ORIGEM dependendo da flag de direção (DF) flag de
EFLAGS.

Se **DF** for 0, os endereços são decrementados e caso contrário são incrementados. Essas instruções normalmente são usadas para
implementar funções de String ou funções que copiam Memória quando o comprimento/largura é conhecido em tempo de compilação. Em alguns
casos são acompanhados pelo prefixo _RET_, que repete uma instrução até **ECX** vezes. Considere o seguinte exemplo :


*Assembly - código 0x04*

		01: BE 28 B5 41 00 mov esi, offset _RamdiskBootDiskGuid
		; ESI = ponteiro para RamdiskBootDiskGuid
		02: 8D BD 40 FF FF+ lea edi, [ebp-0C0h]
		; EDI é um endereço em algum lugar da pilha
		03: A5 movsd
		; copies 4 bytes from EDI to ESI; increment cada um por 4
		04: A5 movsd
		; o mesmo que acima
		05: A5 movsd
		; o mesmo que acima
		06: A5 movsd
		; o mesmo que acima


*Pseudo C*

		/* a GUID is 16-byte structure */
		GUID RamDiskBootDiskGuid = ...; // global
		...
		GUID foo;
		memcpy(&foo, &RamdiskBootDiskGuid, sizeof(GUID));



A line 2 merece uma atenção especial. Embora a instrução **LEA** use [], na verdade não lê de um memory address; simplesmente avalia a
expressão entre colchetes e coloca o resultado no registrador de destino(DEST). Por exemplo, se EBP fosse 0x1000, então EDI seria:

		0xF40 (= 0x1000 - 0xC0)

Depois de executar a linha 2. O ponto é que LEA não acessa a memória, apesar a sintaxe enganosa. O exemplo a seguir, de 
**nt!KiInitSystem**, usa o prefixo REP.. vamos ver:


*Assembly - código 0x05*


		01: 6A 08 push 8 ; push 8 on the stack (irá ser explicado ao falar das stacks)
		02: ...
		03: 59 pop ecx ; pop the stack. Basically sets ECX to 8.
		04: ...
		05: BE 00 44 61 00 mov esi, offset _KeServiceDescriptorTable
		06: BF C0 43 61 00 mov edi, offset _KeServiceDescriptorTableShadow
		07: F3 A5 rep movsd ; copy 32 bytes (movsd repete 8 vezes)
		; a partir disso, podemos deduzir que sejam quais forem esses dois objetos, eles terão
		; provavelmente 32 bytes de tamanho.


*Pseudo C*


		memcpy(&KeServiceDescriptorTableShadow, &KeServiceDescriptorTable, 32);


Agora o exemplo final, a **nt!MmInitializeProcessAddressSpace** usa uma combinação variada dessas instruções, devido a cópia não ser
múltipla de 4 bytes :

*Assembly - código 0x06*

		01: 8D B0 70 01 00+ lea esi, [eax+170h]
		; EAX é provavelmente o endereço básico de uma struct. Lembre-se do que dissemos
		; sobre LEA..
		02: 8D BB 70 01 00+ lea edi, [ebx+170h]
		; EBX provavelmente é outra struct do mesmo tipo
		03: A5 movsd
		04: A5 movsd
		05: A5 movsd
		06: 66 A5 movsw
		07: A4 movsb


Depois das linhas 1–2, você sabe que EAX e EBX provavelmente são do mesmo tipo porque estão sendo usados como origem / destino e os
offsets são iguais. Este trecho de código simplesmente copia 15 bytes de um campo de uma struct p/ outra. Notamos que o código também
poderia ser escrito usando a instrução **MOVSB** com um prefixo **REP** e o **ECX**(counter) definido como 15; Entretanto isso seria
ineficiente pois resultaria em 15 leituras em vez de apanas 5.

Outra classe de instrução que movimenta dados com origem/destino implícitos inclui as instruções : **SCAS** e **STOS** . Semelhante aos _MOVS_, essas instruções podem operar em granulalidade de 1,2 ou 4 bytes.

**SCAS** compara implicitamente : __AL / AX / EAX__ com dados que começam no endereço de memória de EDI. EDI é decrementado/incrementado automaticamente dependendo da **DF** flag. Devido à sua semântica, o **SCAS** é comumente usado junto com o prefixo REP para encontrar um byte, word ou dword em um buffer. Por exemplo, a função C strlen () pode ser implementada da seguinte forma:

*Assembly - código 0x07*

		01: 30 C0 xor al, al
		; setando AL p/ 0 (NUL byte).Veremos frequentemente a instrução : XOR reg, reg
		; pattern in code para zerar o valor do registrador.
		02: 89 FB mov ebx, edi
		; save the original pointer to the string
		03: F2 AE repne scasb
		; avance repetidamente um byte de cada vez, desde que AL não corresponda ao
		; byte em EDI, quando esta instrução terminar significa que alcançamos o byte NUL no buffer de string.
		04: 29 DF sub edi, ebx
		; edi agora é onde está o NUL byte location. Subtraia isso do ponteiro original
		; para o tamanho



**STOS** é o mesmo que **SCAS**, exceto que grava o valor de __AL / AX / EAX__  em EDI. Isso é constantemente usado para inicializar um buffer com um valor constante(como memset()). Aqui está um exemplo :

*Assembly - código 0x08*

		01: 33 C0 xor eax, eax ; set EAX to 0
		02: 6A 09 push 9 ; push 9 on the stack
		03: 59 pop ecx ; pop it back in ECX. Now ECX = 9.
		04: 8B FE mov edi, esi ; set the destination address
		05: F3 AB rep stosd; write 36 bytes of zero to the destination buffer (STOSD repeated 9 times)
						   ; this is equivalent lent to memset(edi, 0, 36)


Observação : **LODS** é outra instrução da mesma família. Ela lê um valor de 1, 2 ou 4 bytes do ESI e o armazena em AL, AX ou EAX.



## Operadores Aritiméticos


Operações aritméticas fundamentais, como adição, subtração, multiplicação e divisão, são suportadas nativamente pelo conjunto de
instruções.As operações bit a bit, como AND, OR, XOR, NOT e deslocamento(shifts) para a esquerda e para a direita também têm instruções
correspondentes nativas. Com exceção da multiplicação e divisão, as instruções restantes são diretas em termos de uso. Essas operações
são explicadas com os seguintes Exemplos:


		01: 83 C4 14 add esp, 14h 		; esp = esp + 0x14
		02: 2B C8 sub ecx, eax 			; ecx = ecx - eax
		03: 83 EC 0C sub esp, 0Ch 		; esp = esp - 0xC
		04: 41 inc ecx 					; ecx = ecx + 1
		05: 4F dec edi 					; edi = edi - 1
		06: 83 C8 FF or eax, 0FFFFFFFFh ; eax = eax | 0xFFFFFFFF
		07: 83 E1 07 and ecx, 7 		; ecx = ecx & 7
		08: 33 C0 xor eax, eax 			; eax = eax ^ eax
		09: F7 D7 not edi 				; edi = ~edi
		10: C0 E1 04 shl cl, 4 			; cl = cl << 4
		11: D1 E9 shr ecx, 1 			; ecx = ecx >> 1
		12: C0 C0 03 rol al, 3 			; rotate AL left 3 positions
		13: D0 C8 ror al, 1 			; rotate AL right 1 position


 
As instruções de deslocamento para a esquerda e para a direita (linhas 11-12) merecem alguma explicação, pois são frequentemente 
observadas no código da vida real. Essas instruções são normalmente usadas para otimizar as operações de multiplicação e divisão onde
o multiplicando e o divisor são uma potência de dois. Este tipo de otimização às vezes é conhecido como redução de resistência porque
substitui uma operação computacionalmente cara por uma mais barata. Por exemplo, a divisão inteira é uma operação relativamente lenta,
mas quando o divisor é uma potência de dois, ele pode ser reduzido a bits deslocados para a direita; **100/2 é igual a 100 >> 1**. Da 
mesma forma, a multiplicação por uma potência de dois pode ser reduzido a bits deslocados para a esquerda; **100 * 2 é igual a 100 << 1**.

A multiplicação sem sinal e com sinal é feita através das instruções MUL e IMUL, respectivamente. A instrução MUL tem a seguinte forma
geral: MUL reg/memória. Ou seja, ele só pode operar em valores de registrador ou memória.O registrador é multiplicado por AL, AX ou EAX
e o resultado é armazenado em AX, DX:AX ou EDX:EAX, dependendo da largura do operando. Por exemplo:


		01: F7 E1 mul ecx 					; EDX:EAX = EAX * ECX
		02: F7 66 04 mul dword ptr [esi+4] 	; EDX:EAX = EAX * dword_at(ESI+4)
		03: F6 E1 mul cl 					; AX = AL * CL
		04: 66 F7 E2 mul dx 				; DX:AX = AX * DX

##### Considere alguns outros exemplos concretos:


		01: B8 03 00 00 00 mov eax,3 		 ; set EAX=3
		02: B9 22 22 22 22 mov ecx,22222222h ; set ECX=0x22222222
		03: F7 E1 mul ecx 					 ; EDX:EAX = 3 * 0x22222222 =
	 										 ; 0x66666666
	 									     ; hence, EDX=0, EAX=0x66666666

		04: B8 03 00 00 00 mov eax,3 		 ; set EAX=3
		05: B9 00 00 00 80 mov ecx,80000000h ; set ECX=0x80000000
		06: F7 E1 mul ecx 					 ; EDX:EAX = 3 * 0x80000000 =
		 									 ; 0x180000000
		 									 ; hence, EDX=1, EAX=0x80000000



A razão pela qual o resultado é armazenado em EDX:EAX para multiplicação de 32 bits é porque o resultado pode não caber em um
registrador de 32 bits (como demonstrado nas linhas 4–6).
IMUL tem três formas:


- **■ IMUL reg/mem — Same as MUL**
- **■ IMUL reg1, reg2/mem — reg1 = reg1 * reg2/mem**
- **■ IMUL reg1, reg2/mem, imm — reg1 = reg2 * imm**


Alguns disassemblers encurtam os parâmetros. Por exemplo :

		01: F7 E9 imul ecx 							; EDX:EAX = EAX * ECX
		02: 69 F6 A0 01 00+ imul esi, 1A0h  		; ESI = ESI * 0x1A0
		03: 0F AF CE imul ecx, esi 					; ECX = ECX * ESI


A divisão Unsigned e com sinal é feita por meio das instruções DIV e IDIV, respectivamente. Eles aceitam apenas um parâmetro (divisor)
e têm a seguinte forma: **DIV / IDIV reg / mem**. Dependendo do tamanho do divisor, o _DIV_ usará **AX, DX: AX ou EDX:EAX** como
dividendo e o par quociente / resto resultante é armazenado em AL / AH, AX / DX ou EAX / EDX. Por exemplo:


		01: F7 F1 div ecx 					 ; EDX:EAX / ECX, quotient in EAX,
		02: F6 F1 div cl 					 ; AX / CL, quotient in AL, remainder in AH
		03: F7 76 24 div dword ptr [esi+24h] ; see line 1
		04: B1 02 mov cl,2 					 ; set CL = 2
		05: B8 0A 00 00 00 mov eax,0Ah 		 ; set EAX = 0xA
		06: F6 F1 div cl 					 ; AX/CL = A/2 = 5 in AL (quotient),
		 									 ; AH = 0 (remainder)
		07: B1 02 mov cl,2 					 ; set CL = 2
		08: B8 09 00 00 00 mov eax,09h 		 ; set EAX = 0x9
		09: F6 F1 div cl 					 ; AX/CL = 9/2 = 4 in AL (quotient),
		 									 ; AH = 1 (remainder)



## Stack Operations and Function Invocation



A Stack(pilha) é uma estrutura de dados básica em linguagens de programação e sistemas operacionais. Por exemplo, variáveis locais em C
são armazenadas no function'stack space. Quando o sistema operacional faz a transição de ring 3 para ring 0, ele salva as informações
de estado na stack. Conceitualmente, uma Stack é uma estrutura de dados last-in first-out( ultimo que entra é o primeiro que sai) e
que suporta duas operações: __push e pop__. Empurrar(push) significa colocar algo no topo da pilha; pop significa remover um item do
topo da pilha. Falando concretamente, em x86, uma pilha é uma região de memória contígua apontada por ESP e ela cresce para baixo. As
operações _push / pop_ são feitas por meio das instruções **PUSH / POP** e modificam o ESP implicitamente. A instrução PUSH diminui
ESP e então grava os dados no local apontado por ESP; O POP lê os dados e incrementa o ESP. O valor padrão de incremento / decremento
automático é 4, mas pode ser alterado para 1 ou 2 com uma substituição de prefixo. Na prática, o valor é quase sempre 4 porque o SO
exige que a pilha seja alinhada com DWORDS. Suponha que ESP inicialmente aponte para 0xb20000 e você tenha o seguinte código:



		; initial ESP = 0xb20000
		01: B8 AA AA AA AA mov eax,0AAAAAAAAh
		02: BB BB BB BB BB mov ebx,0BBBBBBBBh
		03: B9 CC CC CC CC mov ecx,0CCCCCCCCh
		04: BA DD DD DD DD mov edx,0DDDDDDDDh
		05: 50 push eax
		; address 0xb1fffc will contain the value 0xAAAAAAAA and ESP
		; will be 0xb1fffc (=0xb20000-4)
		06: 53 push ebx
		; address 0xb1fff8 will contain the value 0xBBBBBBBB and ESP
		; will be 0xb1fff8 (=0xb1fffc-4)
		07: 5E pop esi	
		; ESI will contain the value 0xBBBBBBBB and ESP will be 0xb1fffc
		; (=0xb1fff8+4)
		08: 5F pop edi
		; EDI will contain the value 0xAAAAAAAA and ESP will be 0xb20000
		; (=0xb1fffc+4)


A Figura 1-3 ilustra o layout da Stack.


[stack](https://i.imgur.com/zurwkEh.png)


O **ESP** também pode ser modificado diretamente por outras instruções,como ADD e SUB. Apesar das linguagens de alto nível terem o
conceito de funções que podem ser chamadas e retornadas, o processador não fornece tal abstração. No nível mais baixo, o processador 
opera apenas em objetos concretos, como registradores ou dados vindos da memória. Como as funções são traduzidas no nível da máquina?
Eles são implementados por meio da estrutura de dados da pilha! Considerar a seguinte função :


**C**

		int
		__cdecl addme(short a, short b)
		{
		 return a+b;
		}



**Assembly**

		01: 004113A0 55 push ebp
		02: 004113A1 8B EC mov ebp, esp
		03: ...
		04: 004113BE 0F BF 45 08 movsx eax, word ptr [ebp+8]
		05: 004113C2 0F BF 4D 0C movsx ecx, word ptr [ebp+0Ch]
		06: 004113C6 03 C1 add eax, ecx
		07: ...
		08: 004113CB 8B E5 mov esp, ebp
		09: 004113CD 5D pop ebp
		10: 004113CE C3 retn


__A função é chamada com o seguinte código :__


**C**


		sum = addme(x, y) ;



**Aseembly**


		01: 004129F3 50 push eax
		02: ...
		03: 004129F8 51 push ecx
		04: 004129F9 E8 F1 E7 FF FF call addme
		05: 004129FE 83 C4 08 add esp, 8



Antes de entrar em detalhes, primeiro considere as instruções _CALL / RET_ e as convenções de chamada. A instrução **CALL** realiza
duas operações:

  1. Ele coloca o endereço de retorno (endereço imediatamente após a instrução CALL) na pilha.
  2. Ele muda o EIP para o destino da chamada. Isso transfere efetivamente o controle para o destino da chamada e começa a execução lá.


A instrução **RET** simplesmente coloca o endereço armazenado no topo da pilha no EIP e transfere o controle para ele (literalmente como um “POP EIP”, mas essa sequência de instruções não existe no x86). Por exemplo, se você deseja iniciar a execução em 0x12345678, pode apenas fazer o seguinte:


		01: 68 78 56 34 12 push 0x12345678
		02: C3 ret


A __calling convention__ é um conjunto de regras que ditam como as chamadas de função funcionam no nível da máquina ( baixo nível ).
É definido pela Interface Binária do Aplicativo (ABI) para um sistema específico. Por exemplo, os parâmetros devem ser passados pela
pilha, em registradores ou em ambos? Os parâmetros devem ser passados da esquerda para a direita ou da direita para a esquerda? O
valor de retorno deve ser armazenado na pilha, em registradores ou em ambos?

Existem muitas convenções de chamada, mas as mais populares são : **CDECL, STDCALL, THISCALL e FASTCALL**. (O compilador também pode
gerar sua própria convenção de chamada personalizada, mas essas não serão discutidas aqui.) A Tabela 1-2 resume sua semântica.


[calling conv.](https://i.imgur.com/nrrTP2D.png)



Agora retornamos ao trecho de código para discutir como a função addme é chamada. Nas linhas 1 e 3, os dois parâmetros são colocados
na pilha; ECX e EAX são o primeiro e o segundo parâmetro, respectivamente. A linha 4 invoca a função addme com a instrução CALL. Isso
coloca imediatamente o endereço de retorno, 0x4129FE, na pilha e começa a execução em 0x4113A0. A Figura 1-4 ilustra o layout da pilha
após a linha 4 ser executada.


[smallstack](https://i.imgur.com/BKeaPy8.png)


- Após a execução da linha 4, estamos agora no corpo da função addme. 
- A linha 1 empurra EBP para a pilha. 
- A linha 2 define EBP para o ponteiro da pilha atual.

Essa sequência de duas instruções é normalmente conhecida como prólogo da função porque estabelece um novo frame de função.

- A linha 4 lê o valor no endereço EBP + 8, que é o primeiro parâmetro na pilha; 
- A linha 5 lê o segundo parâmetro.

Observe que os parâmetros são acessados ​​usando EBP como o registrador base. Quando usado neste contexto, EBP é conhecido como o ponteiro
do frame de base (consulte a linha 2) porque aponta para o frame de pilha da função atual e os parâmetros / locais podem ser
acessados ​​em relação a ele. O compilador também pode ser instruído a gerar código que não use EBP como o ponteiro do frame base por
meio de uma otimização chamada omissão do ponteiro do frame. Com essa otimização, o acesso às variáveis ​​e parâmetros locais é feito em
relação ao ESP, e o EBP pode ser usado como um registrador geral como EAX, EBX, ECX e assim por diante. A linha 6 adiciona os números e
salva o resultado em EAX. A linha 8 define o ponteiro da pilha para o ponteiro do frame base.

- A linha 9 ativa o EBP salvo da linha 1 para o EBP.

Essa sequência de duas instruções é comumente referida como o epílogo da função porque está no final da função e restaura o frame de
função anterior. Neste ponto, o topo da pilha contém o endereço de retorno salvo pela instrução CALL em 0x4129F9.

- A linha 10 realiza um RET, que abre a stack e retoma a execução em 0x4129FE.
- A linha 5 no fragmento reduz a pilha em 8 porque o chamador deve limpar a pilha de acordo com a convenção de chamada de CDECL.

Se a função addme tivesse variáveis ​​locais, o código precisaria aumentar a pilha subtraindo ESP após a linha 2. Todas as variáveis ​​locais seriam acessíveis por meio de um deslocamento negativo de EBP.



## Controle de Fluxo


Esta seção descreve como o sistema implementa a execução condicional para construções de alto nível como if/else, switch/case e while/
for. Todos eles são implementados por meio das instruções CMP, TEST, JMP e Jcc e do registrador EFLAGS. A lista a seguir resume as
flags mais comuns em EFLAGS:


**■ ZF/Zero flag — É definido se o resultado da operação anterior for zero.**
**■ SF/Sign flag — Defina para a parte mais significativa do resultado.**
**■ CF/Carry flag — Definido quando o resultado requer um transporte(cary). Isso se aplica a valores sem sinal(unsigned)..**
**■ OF/Overflow flag — Definido se o resultado ultrapassar o tamanho máximo. Aplica-se a valores com sinal(signed)**


As instruções aritméticas atualizam esses sinalizadores com base no resultado. Por exemplo, a instrução SUB EAX, EAX faria com que ZF
fosse definido. As instruções Jcc, onde “cc” é um código condicional, altera o fluxo de controle dependendo desses sinalizadores. Pode
haver até 16 códigos condicionais, mas os mais comuns são descritos na Tabela 1-3.


[Eflags](https://i.imgur.com/Js4vcwb.png)


Como a linguagem assembly não tem um sistema de tipo definido, uma das poucas maneiras de reconhecer tipos com / sem sinal é por meio
desses códigos condicionais. A instrução CMP compara dois operandos e define o código condicional apropriado em EFLAGS; ele compara
dois números subtraindo um do outro sem atualizar o resultado. A instrução TEST faz a mesma coisa, exceto que executa um AND lógico
entre os dois operandos.



#### If-Else

As construções If-else são bastante simples de reconhecer porque envolvem uma comparação / teste seguida por um Jcc. Por exemplo:

**Assembly**


		01: mov esi, [ebp+8]
		02: mov edx, [esi]
		03: test edx, edx
		04: jz short loc_4E31F9
		05: mov ecx, offset _FsRtlFastMutexLookasideList
		06: call _ExFreeToNPagedLookasideList@8
		07: and dword ptr [esi], 0
		08: lea eax, [esi+4]
		09: push eax
		10: call _FsRtlUninitializeBaseMcb@4
		11: loc_4E31F9
		12: pop esi
		13: pop ebp
		14: retn 4
		15: _FsRtlUninitializeLargeMcb@4 endp


**Pseudo C**

		if (*esi == 0) {
		 return;
		}
		ExFreeToNPagedLookasideList(...);
		*esi = 0;
		...
		return;
		OR
		if (*esi != 0) {
		 ...
		 ExFreeToNPagedLookasideList(...);
		 *esi = 0;
		 ...
		}
		return


- A linha 2 lê um valor no local ESI e o armazena em EDX. 
- A linha 3 ANDs EDX consigo mesma e define os sinalizadores apropriados em EFLAGS. Observe que esse padrão é comumente usado para 
saber se um registrador é zero. 
- A linha 4 salta para loc_4E31F9 (linha 12) se ZF = 1. Se ZF = 0, então ele executa 
- A linha 5 e continua até que a função retorne. Observe que existem duas traduções C ligeiramente diferentes, mas logicamente
equivalentes para este trecho.


#### Switch-Case

Um bloco switch-case é uma sequência de instruções if / else. Por exemplo:

**Switch-Case**

		switch(ch) {
		 case 'c':
		 handle_C();
		 break;
		 case 'h':
		 handle_H();
		 break;
		 default:
		 break;
		}
		domore();
		


**If-Else**


		if (ch == 'c') {
		 handle_C();
		} else
		if (ch == 'h') {
		 handle_H();
		}
		domore();
		...



Portanto, a tradução do código de máquina será uma série if / else. O seguinte exemplo simples ilustra a ideia:


**Assembly**

		01: push ebp
		02: mov ebp, esp
		03: mov eax, [ebp+8]
		04: sub eax, 41h
		05: jz short loc_caseA
		06: dec eax
		07: jz short loc_caseB
		08: dec eax
		09: jz short loc_caseC
		10: mov al, 5Ah
		11: movzx eax, al
		12: pop ebp
		13: retn
		14: loc_caseC:
		15: mov al, 43h
		16: movzx eax, al
		17: pop ebp
		18: retn
		19: loc_caseB:
		20: mov al, 42h
		21: movzx eax, al
		22: pop ebp
		23: retn
		24: loc_caseA:
		25: mov al, 41h
		26: movzx eax, al
		27: pop ebp
		28: retn



**C**


		unsigned char switchme(int a)
			{
			 unsigned char res;
			 switch(a) {
			 case 0x41:
			 res = 'A';
			 break;
			 case 0x42:
			 res = 'B';
			 break;
			 case 0x43:
			 res = 'C';
			 break;
			 default:
			 res = 'Z';
			 break;
			 }
			 return res;
			}


Aqui, o compilador sabe que existem apenas cinco casos e o valor do caso é consecutivo; portanto, ele pode construir a tabela de salto
e indexar nela diretamente (linha 3). Sem a tabela de salto, haveria 10 instruções adicionais para testar cada caso e desviar para o
manipulador. (Existem outras formas de otimizações de switch / case, mas não as cobriremos aqui.)



#### Loops


No nível da máquina, os loops são implementados usando uma combinação de instruções Jcc e JMP. Em outras palavras, eles são
implementados usando as construções if / else e goto. A melhor maneira de entender isso é reescrever um loop usando apenas if / else e
goto. Considere o seguinte exemplo:


**Using for**

		for (int i=0; i<10; i++) {
		 printf("%d\n", i);
		}
		printf("done!\n");


**Using if/else and goto**


		int i = 0;
		loop_start:
		 if (i < 10) {
		 printf("%d\n", i);
		 i++;
		 goto loop_start;
		 }
		printf("done!n");



Quando compiladas, as duas versões são idênticas no nível do código de máquina:


		01: 00401002 mov edi, ds:__imp__printf
		02: 00401008 xor esi, esi
		03: 0040100A lea ebx, [ebx+0]
		04: 00401010 loc_401010:
		05: 00401010 push esi
		06: 00401011 push offset Format ; "%d\n"
		07: 00401016 call edi ; __imp__printf
		08: 00401018 inc esi
		09: 00401019 add esp, 8
		10: 0040101C cmp esi, 0Ah
		11: 0040101F jl short loc_401010
		12: 00401021 push offset aDone ; "done!\n"
		13: 00401026 call edi ; __imp__printf
		14: 00401028 add esp, 4



- A linha 1 define EDI para a função printf. 
- A linha 2 define ESI como 0. 
- A linha 4 inicia o loop; no entanto, observe que ele não começa com uma comparação. Não há comparação aqui porque o compilador sabe 
que o contador foi inicializado em 0 (consulte a linha 2) e obviamente será menor que 10, portanto, a verificação será ignorada. As
- Linhas 5–7 chamam a função printf com os parâmetros corretos (especificador de formato e nosso número). 
- A linha 8 incrementa o número. 
- A linha 9 limpa a pilha porque printf usa a convenção de chamada CDECL. 
- A linha 10 verifica se o contador é menor que 0xA. Se for, ele volta para loc_401010. Se o contador não for menor que 0xA, ele
continua a execução. 
- Na linha 12 e termina com um printf.



Uma observação importante a fazer é que o disassembly nos permitiu inferir que o contador é um número inteiro assinado. A linha 11 usa
o código condicional (JL) “menor que”, então sabemos imediatamente que a comparação foi feita em inteiros com sinal. Lembre-se: Se
“acima / abaixo”, não tem sinal; se “menor que / maior que”, é assinado. A amostra L tem uma pequena função, sub_1000AE3B, com o
seguinte laço interessante.


**Assembly**

		01: sub_1000AE3B proc near
		02: push edi
		03: push esi
		04: call ds:lstrlenA
		05: mov edi, eax
		06: xor ecx, ecx
		07: xor edx, edx
		08: test edi, edi
		09: jle short loc_1000AE5B
		10: loc_1000AE4D:
		11: mov al, [edx+esi]
		12: mov [ecx+esi], al
		13: add edx, 3
		14: inc ecx
		15: cmp edx, edi
		16: jl short loc_1000AE4D
		17: loc_1000AE5B:
		18: mov byte ptr [ecx+esi], 0
		19: mov eax, esi
		20: pop edi
		21: retn
		22: sub_1000AE3B endp


**C**


		char *sub_1000AE3B (char *str)
		{
			 int len, i=0, j=0;
			 len = lstrlenA(str);
			 if (len <= 0) {
			 str[j] = 0;
			 return str;
			 }
			 while (j < len) {
			 str[i] = str[j];
			 j = j+3;
			 i = i+1;
			 }
			 str[i] = 0;
			 return str;
		}


A função sub_1000AE3B tem um parâmetro transmitido usando uma convenção de chamada personalizada (ESI contém o parâmetro). 
- A linha 2 salva EDI. 
- A linha 3 chama lstrlenA com o parâmetro; portanto, você sabe imediatamente que ESI é do tipo char *.* 
- A linha 5 salva o valor de retorno (comprimento da string) em EDI. 
- As linhas 6–7 eliminam ECX e EDX. 
- As linhas 8–9 verificam se o comprimento da string é menor ou igual a zero. Se for, o controle é transferido para a linha 18, que
define o valor em ECX + ESI para 0. Se for não, então a execução continua na linha 11, que é o início de um loop. Primeiro, ele lê o
caractere em ESI + EDX (linha 11) e, em seguida, o armazena em ESI + ECX (linha 12). 

Em seguida, ele incrementa o EDX e o ECX em três e um, respectivamente. As linhas 15–16 verificam se EDX é menor que o comprimento da
string; em caso afirmativo, a execução volta ao início do loop. Caso contrário, a execução continua na linha 18.

Pode parecer complicado no início, mas essa função usa uma string ofuscada cujo valor desofuscado está a cada três caracteres. Por
exemplo, a string __SX] OTYFKPTY ^ W \\ aAFKRW \\ E__ é, na verdade, **SOFTWARE**.


O objetivo desta função é prevenir scanners de string ingênuos e evitar a detecção. Como exercício, você deve descompilar esta função
para que pareça mais “natural” (ao contrário de nossa tradução literal).

Fora das construções Jcc normais, certos loops podem ser implementados usando a instrução LOOP. A instrução LOOP executa um bloco de
código até a hora ECX. Por exemplo:


**Assembly**

		01: 8B CA mov ecx, edx
		02: loc_CFB8F:
		03: AD lodsd
		04: F7 D0 not eax
		05: AB stosd
		06: E2 FA loop loc_CFB8F

**Rough C**

		while (ecx != 0) {
		 eax = *edi;
		 edi++;
		 *esi = ~eax;
		 esi++;
		 ecx--;
		}


A linha 1 lê o contador do EDX. A linha 3 é o início do loop; ele lê uma palavra dupla no endereço de memória EDI e salva em EAX;
também incrementa o EDI em 4. A linha 4 executa o operador NOT no valor que acabou de ler. A linha 5 grava o valor modificado no
endereço de memória ESI e incrementa o ESI em 4. A linha 6 verifica se ECX é 0; caso contrário, a execução continua no início do loop.



## Mecanismo do Sistema



As seções anteriores explicam os mecanismos e instruções disponíveis para código em execução em todos os níveis de privilégio. Para
obter uma melhor apreciação da arquitetura, esta seção discute dois mecanismos fundamentais no nível do sistema: tradução de endereço
virtual e tratamento de exceções / interrupções. Você pode pular esta seção na primeira leitura.


### Address Translation  ( Tradução de Endereços )






